<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="MVVM 与 ReactiveCocoa"><meta name="keywords" content="iOS"><meta name="author" content="Zhen,undefined"><meta name="copyright" content="Zhen"><title>MVVM 与 ReactiveCocoa | Zhen's Blog</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.json","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM模式与RAC"><span class="toc-number">1.</span> <span class="toc-text">MVVM模式与RAC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Delegate"><span class="toc-number">1.1.</span> <span class="toc-text">Delegate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KVO"><span class="toc-number">1.2.</span> <span class="toc-text">KVO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#细节处理"><span class="toc-number">1.3.</span> <span class="toc-text">细节处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tips"><span class="toc-number">1.4.</span> <span class="toc-text">Tips</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpeg"></div><div class="author-info__name text-center">Zhen</div><div class="author-info__description text-center">Whoever does not rest will not work.</div><div class="follow-button"><a href="https://www.baidu.com" target="_blank">baidu</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">1</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://img.zcool.cn/community/013a4456f2626f32f875a944208731.jpg@2o.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Zhen's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于</a></span></div><div id="post-info"><div id="post-title">MVVM 与 ReactiveCocoa</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-10</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">1,843</span><span class="post-meta__separator">|</span><span>阅读时长: 7 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="MVVM模式与RAC"><a href="#MVVM模式与RAC" class="headerlink" title="MVVM模式与RAC"></a>MVVM模式与RAC</h2><p>  <strong>MVVM</strong> 是 <strong>MVC</strong> 模式的一种演进，它主要解决了 <strong>ViewController</strong> 过于臃肿带来的不易维护和测试的问题。其中 <strong>ViewModel</strong> 的主要职 责是处理业务逻辑并提供 <strong>View</strong> 所需的数据，这样 <strong>VC</strong> 就不用关心业务，自然也就瘦了下来。<strong>ViewModel</strong> 只关心业务数据不关心 <strong>View</strong>，所以不会与 <strong>View</strong> 产生耦合，也就更方便进行单元测试。</p>
<p>  <strong>View</strong> 是一个壳，它所呈现的内容都需要由 <strong>ViewModel</strong> 来提供，而 <strong>View</strong> 又不与 <strong>ViewModel</strong> 直接沟通，这时就需要 <strong>ViewController</strong> 来做中间的协调者。<br><strong>ViewController</strong> 持有 <strong>View</strong>和 <strong>ViewModel</strong>，当 <strong>VC</strong>初始化时，会让 <strong>ViewModel</strong> 去取数据，简单来说就是调用 <strong>VM</strong> 的某个获取数据的方法。</p>
<p>  使用 <strong>MVVM</strong> 最舒服的姿势是搭配 <strong>ReactiveCocoa</strong>。不过它的问题在于学习成本和维护成本比较高，在小团队中或许还可以尝试，当开发人员数量较多时就很难推起来了。这也是我们今天要讲的主题：如何不借助 <strong>ReactiveCocoa</strong> 来实现 <strong>MVVM</strong>。</p>
<hr>
<p>  先从数据的获取开始说起吧。在 <strong>ReactiveCocoa</strong> 里有一个类叫「RACCommand」，它的主要作用是执行某个会改变数据的操作，然后提供获取数据的方法，跟我们想要达到的目的很像，所以可以借鉴这个思路，写一个简单的 Command。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^MGJCommandCompletionBlock)(id error, id content);</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">typedef void(^MGJCommandConsumeBlock)(id input, MGJCommandCompletionBlock completionHandler);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">typedef void(^MGJCommandCancelBlock)();</span><br><span class="line"></span><br><span class="line">@interface MGJCommandResult : NSObject</span><br><span class="line">// 3</span><br><span class="line">@property (nonatomic) NSError *error;</span><br><span class="line">// 4</span><br><span class="line">@property (nonatomic) id content;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface MGJCommand : NSObject</span><br><span class="line"></span><br><span class="line">// 5</span><br><span class="line">@property (nonatomic, readonly) BOOL executing;</span><br><span class="line">// 6</span><br><span class="line">@property (nonatomic, readonly) MGJCommandResult *result;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithConsumeHandler:(MGJCommandConsumeBlock )consumeHandler;</span><br><span class="line">// 7</span><br><span class="line">- (instancetype)initWithConsumeHandler:(MGJCommandConsumeBlock )consumeHandler cancelHandler:(MGJCommandCancelBlock )cancelHandler;</span><br><span class="line"></span><br><span class="line">// 8</span><br><span class="line">- (void)execute:(id)input;</span><br><span class="line">// 9</span><br><span class="line">- (void)cancel;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>1.<strong>input</strong>是外部传过来的值，比如 user_id，当拿到数据后，调用下 <strong>completionHandler</strong>，这样 <strong>result</strong> 属性就会变化<br>2.有些操作，如 <strong>http</strong> 请求，需要手动取消<br>3.单独把 <strong>error</strong>作为一个属性放出来，是因为很多数据请求操作都可能出错，当出错后，只需改变这个 <strong>error</strong> 属性即可。<br>4.<strong>content</strong> 存放了这个 <strong>Command</strong> 的数据处理结果。<br>5.标识了这个 <strong>Command</strong> 目前的运行状态，比如可以根据这个状态来显示 <strong>loading</strong>。<br>6.每次 <strong>Command</strong> 执行完一个任务后，<strong>result</strong> 都会改变，外部可以 <strong>KVO</strong> 这个 <strong>result</strong>，然后就可以实时获取最新的结果了。<br>7.<strong>Command</strong> 的执行逻辑，如果实现了 <strong>cancelHandler</strong> 的话，外部调用 <strong>cancel</strong>，这个 <strong>Handler</strong> 就会被触发。<br>8.外部可以调用这个方法来触发 <strong>Command</strong> 的执行，同时可以传一个参数进来。<br>9.外部可以调用这个方法来取消 <strong>Command</strong> 的执行。</p>
<p>实现起来也蛮简单的，这里就不多说了。用起来大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SomeViewModel.m</span><br><span class="line">@weakify(self);</span><br><span class="line">self.followCommand = [[MGJCommand alloc] initWithConsumeHandler:^(id input, MGJCommandCompletionBlock completionHandler) &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    [FollowRequest getFollowList:(NSDictionary *)input success:^(NSArray *users) &#123;</span><br><span class="line">        self.usersToFollow = users;</span><br><span class="line">        completionHandler(nil, kFollowExpertSearchSucceedSignal);</span><br><span class="line">    &#125; failure:^(StatusEntity *error) &#123;</span><br><span class="line">        completionHandler(error, nil);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>在 <strong>ViewController</strong> 里的用法大概像这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SomeViewController.m</span><br><span class="line"></span><br><span class="line">- (void)didTapFollowButton:(UIButton *)button</span><br><span class="line">&#123;</span><br><span class="line">	// 根据 button 找到 userID</span><br><span class="line">	[self.viewModel.followCommand execute:userID];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是这样，<strong>VC</strong> 本身不处理业务逻辑，都交给 <strong>ViewModel</strong> 去处理，而这些数据请求的结果处理又有不同的处理方式。</p>
<hr>
<h3 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a>Delegate</h3><p>当 <strong>ViewModel</strong> 拿到数据后，可以把结果以 <strong>Delegate</strong> 的方式通知 <strong>VC</strong>，就像这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SomeViewController.m</span><br><span class="line"></span><br><span class="line">- (void)didFollowUserWithResult:(id)result</span><br><span class="line">&#123;</span><br><span class="line">	self.followButton.enabled = YES;</span><br><span class="line">	[self.followButton doSomeAnimation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样做的好处是比较符合苹果既有的设计模式，而且也可以通过查看 <strong>Delegate</strong> 协议来知道 <strong>VM</strong> 暴露了哪些接口供外部使用。</p>
<p>不过这种方法少了点灵活性，比如需要联合多个属性的变化来做一些事情时，处理起来就会比较麻烦，这也是 <strong>RAC</strong> 强大的地方。</p>
<hr>
<h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p><strong>RAC</strong> 是基于 <strong>KVO</strong> 构建的，所以也可以用 <strong>KVO</strong> 来让 <strong>VC</strong> 获取 <strong>VM</strong> 的变化。<br>但我们都知道 <strong>KVO</strong> 的槽点比较多，比如使用起来不方便，用完还要记得移除等。这里可以使用 Facebook 开源的 KVOController，它比较好的处理了 <strong>KVO</strong> 存在的一些问题，同时又能发挥 <strong>KVO</strong> 带来的便捷性。<br>有了它我们就能在一个地方把 VM 的更新处理掉了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleViewModelUpdate</span><br><span class="line">&#123;</span><br><span class="line">	[self.KVOController observe:self.viewModel keyPath:@&quot;followCommand.result&quot; options:NSKeyValueObservingOptionInitial|NSKeyValueObservingOptionNew block:^(id observer, id target, NSDictionary *change) &#123;</span><br><span class="line">		id newValue = change[NSKeyValueChangeNewKey];</span><br><span class="line">		// doSomething with the newValue</span><br><span class="line">	&#125;];</span><br><span class="line"></span><br><span class="line">	// 对 VM 其他 keyPath 的处理也都可以放到这里</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果觉得这样的写法还是太麻烦，可以做一层简单的封装，使用起来就像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleViewModelUpdate</span><br><span class="line">&#123;</span><br><span class="line">	[self observe:self.viewModel keyPath:@&quot;followCommand.result&quot; block: ^(id newValue)&#123;</span><br><span class="line">		// use newValue to update view</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是会好一点，使用 <strong>KVO</strong> 比 <strong>Delegate</strong> 好的一点是不用再额外声明协议和方法，而且支持 <strong>block</strong>，使用起来也会方便些。<br>对于像 <strong>error</strong> 这样很多操作都会产生同样结果的场景，可以单独拿出来，作为 <strong>ViewModel</strong> 的一个属性，使用时，直接 <strong>KVO</strong> 这个属性即可。</p>
<hr>
<h3 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h3><p>如果不涉及到 <strong>TableView</strong> 等会出现复用场景的地方，<strong>MVVM</strong> 使用起来还是比较方便的。如果有了 <strong>TableView</strong>，又要做一些额外的处理。</p>
<p>一般来说，<strong>VC</strong> 可以带一个 <strong>VM</strong>，那如果出现 <strong>Cell</strong> 时怎么办，<strong>Cell</strong> 里又包含了按钮，按钮又需要数据请求又怎么处理？这些都是比较常见的场景，也可以通过 <strong>MVVM</strong> 来解决。</p>
<p>我们知道 <strong>VM</strong> 的职责是为 <strong>View</strong> 提供数据支持，<strong>Cell</strong> 也是一个 <strong>View</strong>，那么为 <strong>Cell</strong> 配备一个 <strong>VM</strong> 不就可以了么。</p>
<p>这样的话，<strong>VC</strong> 的 <strong>VM</strong> 需要包含一个数组，里面的元素是 <strong>CellVM</strong>，使用起来就像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SomeViewController.m</span><br><span class="line"></span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">	UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;Cell&quot; forIndexPath:indexPath];</span><br><span class="line">	cell.viewModel = self.viewModel.cellViewModels[indexPath.row];</span><br><span class="line"></span><br><span class="line">	// cell 可能会用到 cellVM 里的 Command，所以在这里处理 command 的执行结果</span><br><span class="line">	[self observe:cell keyPath:@&quot;likeCommand.result&quot; block: ^(id newValue)&#123;</span><br><span class="line">		// update cell after like</span><br><span class="line">	&#125;];</span><br><span class="line"></span><br><span class="line">	return cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然仅仅如此是不够的，我们需要找个恰当的时机把 <strong>KVO</strong> 移除，避免多次监听。<strong>UITableViewDelegate</strong> 里的这个方法就很适合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// SomeViewController.m</span><br><span class="line"></span><br><span class="line">- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">	[self unobserve:cell keyPath:@&quot;likeCommand.result&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这里也要讲究一个平衡，如果 <strong>Cell</strong> 的类型比较多，且涉及 <strong>Command</strong> 的地方不多，只是做呈现方面的工作，直接使用 <strong>Entity</strong> 会更方便。</p>
<hr>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol>
<li><strong>ViewController</strong> 尽量不涉及业务逻辑，让 <strong>ViewModel</strong> 去做这些事情。</li>
<li><strong>ViewController</strong> 只是一个中间人，接收 <strong>View</strong> 的事件、调用 <strong>ViewModel</strong> 的方法、响应 <strong>ViewModel</strong> 的变化。</li>
<li><strong>ViewModel</strong> 不能包含 <strong>View</strong>，不然就跟 <strong>View</strong> 产生了耦合，不方便复用和测试。</li>
<li><strong>ViewModel</strong> 之间可以有依赖。</li>
<li><strong>ViewModel</strong> 避免过于臃肿，不然维护起来也是个问题。<br><strong>MVVM</strong> 并不复杂，跟 <strong>MVC</strong> 也是兼容的，只是多了一个 <strong>ViewModel</strong> 层，但就是这么一个小改动，就能让代码变得更加容易阅读和维护，不妨试一下吧。</li>
</ol>
<hr>
<p>以上为记录贴</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  owner: 'Kucz',
  repo: 'Kucz.github.io',
  oauth: {
    client_id: 'cef955c854ea2030d64e',
    client_secret: '0f5d80b0d20fd69d6bce6dbd74388bda64c3af49'
  }
})
gitment.render('gitment-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 By Zhen</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>