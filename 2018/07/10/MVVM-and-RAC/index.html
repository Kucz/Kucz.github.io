<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Whoever does not rest will not work.">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon">

    <title>
        
        MVVM and RAC - Zhen&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 谁不会休息，谁就不会工作。——列宁 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/timg.jpeg" />
        </div>
        <div class="name">
            <i>曹震</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM模式与RAC"><span class="toc-text">MVVM模式与RAC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#就是这样，VC-本身不处理业务逻辑，都交给-ViewModel-去处理，而这些数据请求的结果处理又有不同的处理方式。"><span class="toc-text">就是这样，VC 本身不处理业务逻辑，都交给 ViewModel 去处理，而这些数据请求的结果处理又有不同的处理方式。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Delegate"><span class="toc-text">Delegate</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不过这种方法少了点灵活性，比如需要联合多个属性的变化来做一些事情时，处理起来就会比较麻烦，这也是-RAC-强大的地方。"><span class="toc-text">不过这种方法少了点灵活性，比如需要联合多个属性的变化来做一些事情时，处理起来就会比较麻烦，这也是 RAC 强大的地方。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KVO"><span class="toc-text">KVO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对于像-error-这样很多操作都会产生同样结果的场景，可以单独拿出来，作为-ViewModel-的一个属性，使用时，直接-KVO-这个属性即可。"><span class="toc-text">对于像 error 这样很多操作都会产生同样结果的场景，可以单独拿出来，作为 ViewModel 的一个属性，使用时，直接 KVO 这个属性即可。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#细节处理"><span class="toc-text">细节处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tips"><span class="toc-text">Tips</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 谁不会休息，谁就不会工作。——列宁 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        MVVM and RAC
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2018-07-10 13:46:58</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#iOS" title="iOS">iOS</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h2 id="MVVM模式与RAC"><a href="#MVVM模式与RAC" class="headerlink" title="MVVM模式与RAC"></a>MVVM模式与RAC</h2><p>  MVVM 是 MVC 模式的一种演进，它主要解决了 ViewController 过于臃肿带来的不易维护和测试的问题。其中 ViewModel 的主要职 责是处理业务逻辑并提供 View 所需的数据，这样 VC 就不用关心业务，自然也就瘦了下来。ViewModel 只关心业务数据不关心 View，所以不会与 View 产生耦合，也就更方便进行单元测试。</p>
<p>  View 是一个壳，它所呈现的内容都需要由 ViewModel 来提供，而 View 又不与 ViewModel 直接沟通，这时就需要 ViewController 来做中间的协调者。<br>ViewController 持有 View 和 ViewModel，当 VC 初始化时，会让 ViewModel 去取数据，简单来说就是调用 VM 的某个获取数据的方法。</p>
<p>  使用 MVVM 最舒服的姿势是搭配 ReactiveCocoa。不过它的问题在于学习成本和维护成本比较高，在小团队中或许还可以尝试，当开发人员数量较多时就很难推起来了。这也是我们今天要讲的主题：如何不借助 ReactiveCocoa 来实现 MVVM。</p>
<p>  先从数据的获取开始说起吧。在 ReactiveCocoa 里有一个类叫「RACCommand」，它的主要作用是执行某个会改变数据的操作，然后提供获取数据的方法，跟我们想要达到的目的很像，所以可以借鉴这个思路，写一个简单的 Command。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^MGJCommandCompletionBlock)(id error, id content);</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">typedef void(^MGJCommandConsumeBlock)(id input, MGJCommandCompletionBlock completionHandler);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">typedef void(^MGJCommandCancelBlock)();</span><br><span class="line"></span><br><span class="line">@interface MGJCommandResult : NSObject</span><br><span class="line">// 3</span><br><span class="line">@property (nonatomic) NSError *error;</span><br><span class="line">// 4</span><br><span class="line">@property (nonatomic) id content;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface MGJCommand : NSObject</span><br><span class="line"></span><br><span class="line">// 5</span><br><span class="line">@property (nonatomic, readonly) BOOL executing;</span><br><span class="line">// 6</span><br><span class="line">@property (nonatomic, readonly) MGJCommandResult *result;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithConsumeHandler:(MGJCommandConsumeBlock )consumeHandler;</span><br><span class="line">// 7</span><br><span class="line">- (instancetype)initWithConsumeHandler:(MGJCommandConsumeBlock )consumeHandler cancelHandler:(MGJCommandCancelBlock )cancelHandler;</span><br><span class="line"></span><br><span class="line">// 8</span><br><span class="line">- (void)execute:(id)input;</span><br><span class="line">// 9</span><br><span class="line">- (void)cancel;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>1.<font color="gray" bgcolor="black">input</font> 是外部传过来的值，比如 user_id，当拿到数据后，调用下 completionHandler，这样 result 属性就会变化<br>2.有些操作，如 http 请求，需要手动取消<br>3.单独把 error 作为一个属性放出来，是因为很多数据请求操作都可能出错，当出错后，只需改变这个 error 属性即可。<br>4.content 存放了这个 Command 的数据处理结果。<br>5.标识了这个 Command 目前的运行状态，比如可以根据这个状态来显示 loading。<br>6.每次 Command 执行完一个任务后，result 都会改变，外部可以 KVO 这个 result，然后就可以实时获取最新的结果了。<br>7.Command 的执行逻辑，如果实现了 cancelHandler 的话，外部调用 cancel，这个 Handler 就会被触发。<br>8.外部可以调用这个方法来触发 Command 的执行，同时可以传一个参数进来。<br>9.外部可以调用这个方法来取消 Command 的执行。</p>
<p>实现起来也蛮简单的，这里就不多说了。用起来大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SomeViewModel.m</span><br><span class="line">@weakify(self);</span><br><span class="line">self.followCommand = [[MGJCommand alloc] initWithConsumeHandler:^(id input, MGJCommandCompletionBlock completionHandler) &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    [FollowRequest getFollowList:(NSDictionary *)input success:^(NSArray *users) &#123;</span><br><span class="line">        self.usersToFollow = users;</span><br><span class="line">        completionHandler(nil, kFollowExpertSearchSucceedSignal);</span><br><span class="line">    &#125; failure:^(StatusEntity *error) &#123;</span><br><span class="line">        completionHandler(error, nil);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>在 ViewController 里的用法大概像这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SomeViewController.m</span><br><span class="line"></span><br><span class="line">- (void)didTapFollowButton:(UIButton *)button</span><br><span class="line">&#123;</span><br><span class="line">	// 根据 button 找到 userID</span><br><span class="line">	[self.viewModel.followCommand execute:userID];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="就是这样，VC-本身不处理业务逻辑，都交给-ViewModel-去处理，而这些数据请求的结果处理又有不同的处理方式。"><a href="#就是这样，VC-本身不处理业务逻辑，都交给-ViewModel-去处理，而这些数据请求的结果处理又有不同的处理方式。" class="headerlink" title="就是这样，VC 本身不处理业务逻辑，都交给 ViewModel 去处理，而这些数据请求的结果处理又有不同的处理方式。"></a>就是这样，VC 本身不处理业务逻辑，都交给 ViewModel 去处理，而这些数据请求的结果处理又有不同的处理方式。</h2><h3 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a>Delegate</h3><p>当 ViewModel 拿到数据后，可以把结果以 Delegate 的方式通知 VC，就像这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SomeViewController.m</span><br><span class="line"></span><br><span class="line">- (void)didFollowUserWithResult:(id)result</span><br><span class="line">&#123;</span><br><span class="line">	self.followButton.enabled = YES;</span><br><span class="line">	[self.followButton doSomeAnimation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样做的好处是比较符合苹果既有的设计模式，而且也可以通过查看 Delegate 协议来知道 VM 暴露了哪些接口供外部使用。</p>
<h2 id="不过这种方法少了点灵活性，比如需要联合多个属性的变化来做一些事情时，处理起来就会比较麻烦，这也是-RAC-强大的地方。"><a href="#不过这种方法少了点灵活性，比如需要联合多个属性的变化来做一些事情时，处理起来就会比较麻烦，这也是-RAC-强大的地方。" class="headerlink" title="不过这种方法少了点灵活性，比如需要联合多个属性的变化来做一些事情时，处理起来就会比较麻烦，这也是 RAC 强大的地方。"></a>不过这种方法少了点灵活性，比如需要联合多个属性的变化来做一些事情时，处理起来就会比较麻烦，这也是 RAC 强大的地方。</h2><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>RAC 是基于 KVO 构建的，所以也可以用 KVO 来让 VC 获取 VM 的变化。<br>但我们都知道 KVO 的槽点比较多，比如使用起来不方便，用完还要记得移除等。这里可以使用 Facebook 开源的 KVOController，它比较好的处理了 KVO 存在的一些问题，同时又能发挥 KVO 带来的便捷性。<br>有了它我们就能在一个地方把 VM 的更新处理掉了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleViewModelUpdate</span><br><span class="line">&#123;</span><br><span class="line">	[self.KVOController observe:self.viewModel keyPath:@&quot;followCommand.result&quot; options:NSKeyValueObservingOptionInitial|NSKeyValueObservingOptionNew block:^(id observer, id target, NSDictionary *change) &#123;</span><br><span class="line">		id newValue = change[NSKeyValueChangeNewKey];</span><br><span class="line">		// doSomething with the newValue</span><br><span class="line">	&#125;];</span><br><span class="line"></span><br><span class="line">	// 对 VM 其他 keyPath 的处理也都可以放到这里</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果觉得这样的写法还是太麻烦，可以做一层简单的封装，使用起来就像这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleViewModelUpdate</span><br><span class="line">&#123;</span><br><span class="line">	[self observe:self.viewModel keyPath:@&quot;followCommand.result&quot; block: ^(id newValue)&#123;</span><br><span class="line">		// use newValue to update view</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不是会好一点，使用 KVO 比 Delegate 好的一点是不用再额外声明协议和方法，而且支持 block，使用起来也会方便些。</p>
<h2 id="对于像-error-这样很多操作都会产生同样结果的场景，可以单独拿出来，作为-ViewModel-的一个属性，使用时，直接-KVO-这个属性即可。"><a href="#对于像-error-这样很多操作都会产生同样结果的场景，可以单独拿出来，作为-ViewModel-的一个属性，使用时，直接-KVO-这个属性即可。" class="headerlink" title="对于像 error 这样很多操作都会产生同样结果的场景，可以单独拿出来，作为 ViewModel 的一个属性，使用时，直接 KVO 这个属性即可。"></a>对于像 error 这样很多操作都会产生同样结果的场景，可以单独拿出来，作为 ViewModel 的一个属性，使用时，直接 KVO 这个属性即可。</h2><h3 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h3><p>如果不涉及到 TableView 等会出现复用场景的地方，MVVM 使用起来还是比较方便的。如果有了 TableView，又要做一些额外的处理。</p>
<p>一般来说，VC 可以带一个 VM，那如果出现 Cell 时怎么办，Cell 里又包含了按钮，按钮又需要数据请求又怎么处理？这些都是比较常见的场景，也可以通过 MVVM 来解决。</p>
<p>我们知道 VM 的职责是为 View 提供数据支持，Cell 也是一个 View，那么为 Cell 配备一个 VM 不就可以了么。</p>
<p>这样的话，VC 的 VM 需要包含一个数组，里面的元素是 CellVM，使用起来就像这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SomeViewController.m</span><br><span class="line"></span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">	UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;Cell&quot; forIndexPath:indexPath];</span><br><span class="line">	cell.viewModel = self.viewModel.cellViewModels[indexPath.row];</span><br><span class="line"></span><br><span class="line">	// cell 可能会用到 cellVM 里的 Command，所以在这里处理 command 的执行结果</span><br><span class="line">	[self observe:cell keyPath:@&quot;likeCommand.result&quot; block: ^(id newValue)&#123;</span><br><span class="line">		// update cell after like</span><br><span class="line">	&#125;];</span><br><span class="line"></span><br><span class="line">	return cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然仅仅如此是不够的，我们需要找个恰当的时机把 KVO 移除，避免多次监听。UITableViewDelegate 里的这个方法就很适合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// SomeViewController.m</span><br><span class="line"></span><br><span class="line">- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">	[self unobserve:cell keyPath:@&quot;likeCommand.result&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过这里也要讲究一个平衡，如果 Cell 的类型比较多，且涉及 Command 的地方不多，只是做呈现方面的工作，直接使用 Entity 会更方便。</p>
<hr>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol>
<li>ViewController 尽量不涉及业务逻辑，让 ViewModel 去做这些事情。</li>
<li>ViewController 只是一个中间人，接收 View 的事件、调用 ViewModel 的方法、响应 ViewModel 的变化。</li>
<li>ViewModel 不能包含 View，不然就跟 View 产生了耦合，不方便复用和测试。</li>
<li>ViewModel 之间可以有依赖。</li>
<li>ViewModel 避免过于臃肿，不然维护起来也是个问题。<br>MVVM 并不复杂，跟 MVC 也是兼容的，只是多了一个 ViewModel 层，但就是这么一个小改动，就能让代码变得更加容易阅读和维护，不妨试一下吧。</li>
</ol>

        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>

<!-- 
<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>


 -->

</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/js/gitment.js"></script>
<script>
    var gitment = new Gitment({
        id: 'MVVM and RAC',
        owner: 'Kucz',
        repo: 'Kucz.github.io',
        oauth: {
            client_id: 'cef955c854ea2030d64e',
            client_secret: '0f5d80b0d20fd69d6bce6dbd74388bda64c3af49',
        },
    })
    gitment.render('comment-container')
</script>

</html>
