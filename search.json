[{"title":"MVVM and RAC","url":"/2018/07/10/MVVM-and-RAC/","content":"\n## MVVM模式与RAC\n  MVVM 是 MVC 模式的一种演进，它主要解决了 ViewController 过于臃肿带来的不易维护和测试的问题。其中 ViewModel 的主要职 责是处理业务逻辑并提供 View 所需的数据，这样 VC 就不用关心业务，自然也就瘦了下来。ViewModel 只关心业务数据不关心 View，所以不会与 View 产生耦合，也就更方便进行单元测试。\n\n  View 是一个壳，它所呈现的内容都需要由 ViewModel 来提供，而 View 又不与 ViewModel 直接沟通，这时就需要 ViewController 来做中间的协调者。\nViewController 持有 View 和 ViewModel，当 VC 初始化时，会让 ViewModel 去取数据，简单来说就是调用 VM 的某个获取数据的方法。\n\n  使用 MVVM 最舒服的姿势是搭配 ReactiveCocoa。不过它的问题在于学习成本和维护成本比较高，在小团队中或许还可以尝试，当开发人员数量较多时就很难推起来了。这也是我们今天要讲的主题：如何不借助 ReactiveCocoa 来实现 MVVM。\n\n  先从数据的获取开始说起吧。在 ReactiveCocoa 里有一个类叫「RACCommand」，它的主要作用是执行某个会改变数据的操作，然后提供获取数据的方法，跟我们想要达到的目的很像，所以可以借鉴这个思路，写一个简单的 Command。\n\n```\ntypedef void(^MGJCommandCompletionBlock)(id error, id content);\n\n// 1\ntypedef void(^MGJCommandConsumeBlock)(id input, MGJCommandCompletionBlock completionHandler);\n\n// 2\ntypedef void(^MGJCommandCancelBlock)();\n\n@interface MGJCommandResult : NSObject\n// 3\n@property (nonatomic) NSError *error;\n// 4\n@property (nonatomic) id content;\n@end\n\n@interface MGJCommand : NSObject\n\n// 5\n@property (nonatomic, readonly) BOOL executing;\n// 6\n@property (nonatomic, readonly) MGJCommandResult *result;\n\n- (instancetype)initWithConsumeHandler:(MGJCommandConsumeBlock )consumeHandler;\n// 7\n- (instancetype)initWithConsumeHandler:(MGJCommandConsumeBlock )consumeHandler cancelHandler:(MGJCommandCancelBlock )cancelHandler;\n\n// 8\n- (void)execute:(id)input;\n// 9\n- (void)cancel;\n@end\n```\n1.<font color=gray size=72>input</font> 是外部传过来的值，比如 user_id，当拿到数据后，调用下 completionHandler，这样 result 属性就会变化\n2.有些操作，如 http 请求，需要手动取消\n3.单独把 error 作为一个属性放出来，是因为很多数据请求操作都可能出错，当出错后，只需改变这个 error 属性即可。\n4.content 存放了这个 Command 的数据处理结果。\n5.标识了这个 Command 目前的运行状态，比如可以根据这个状态来显示 loading。\n6.每次 Command 执行完一个任务后，result 都会改变，外部可以 KVO 这个 result，然后就可以实时获取最新的结果了。\n7.Command 的执行逻辑，如果实现了 cancelHandler 的话，外部调用 cancel，这个 Handler 就会被触发。\n8.外部可以调用这个方法来触发 Command 的执行，同时可以传一个参数进来。\n9.外部可以调用这个方法来取消 Command 的执行。\n\n实现起来也蛮简单的，这里就不多说了。用起来大概是这样：\n```\n// SomeViewModel.m\n@weakify(self);\nself.followCommand = [[MGJCommand alloc] initWithConsumeHandler:^(id input, MGJCommandCompletionBlock completionHandler) {\n    @strongify(self);\n    [FollowRequest getFollowList:(NSDictionary *)input success:^(NSArray *users) {\n        self.usersToFollow = users;\n        completionHandler(nil, kFollowExpertSearchSucceedSignal);\n    } failure:^(StatusEntity *error) {\n        completionHandler(error, nil);\n    }];\n}];\n```\n在 ViewController 里的用法大概像这样\n```\n// SomeViewController.m\n\n- (void)didTapFollowButton:(UIButton *)button\n{\n\t// 根据 button 找到 userID\n\t[self.viewModel.followCommand execute:userID];\n}\n```\n就是这样，VC 本身不处理业务逻辑，都交给 ViewModel 去处理，而这些数据请求的结果处理又有不同的处理方式。\n\n","tags":["iOS"]}]