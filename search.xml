<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>iOS App本地化</title>
      <link href="/2018/07/12/iOS-App%E6%9C%AC%E5%9C%B0%E5%8C%96/"/>
      <url>/2018/07/12/iOS-App%E6%9C%AC%E5%9C%B0%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="App本地化"><a href="#App本地化" class="headerlink" title="App本地化"></a>App本地化</h2><p>语言本地化，又叫做语言国际化。是指根据用户操作系统的语言设置，自动将应用程序的语言设置为和用户操作系统语言一致的语言。往往一些应用程序需要提供给多个国家的人群使用，或者一个国家有多种语言，这就要求应用程序所展示的文字、图片等信息，能够让讲不同语言的用户读懂、看懂。进而提出为同一个应用程序适配多种语言，也即是国际化。语言国际化之所以又叫做语言本地化，这是站在每个用户的角度而言的，是指能够让用户本地、本土人群能够看懂的语言信息，顾名思义，语言本地化。</p><hr><p>本文从以下六个方面入手</p><ul><li>配置需要国际化的语言（国际化的准备工作）</li><li>App名称本地化</li><li>代码中字符串本地化</li><li>多人开发情况下的字符串本地化</li><li>图片本地化（两种方式两种方式）</li><li>查看/切换本地语言<!-- * storyboard/xib本地化 --></li></ul><h3 id="配置需要国际化"><a href="#配置需要国际化" class="headerlink" title="配置需要国际化"></a>配置需要国际化</h3><ul><li>选中project-&gt;Info-&gt;Localizations，然后点击”+”，添加需要国际化/本地化的语言，如下图（默认需要勾选Use Base Internationalization）：<br><img src="/img/iOS本地化/peizhibendihua.png" alt=""></li><li>以添加简体中文为例：<br><img src="/img/iOS本地化/chooseLanguage.png" alt=""></li><li>添加简体中文后弹出如下对话框，直接点击finish，如下图：<br><img src="/img/iOS本地化/chooseSuccess.png" alt=""></li><li>添加其他语言同上述流程</li></ul><hr><h3 id="应用名称本地化-国际化"><a href="#应用名称本地化-国际化" class="headerlink" title="应用名称本地化/国际化"></a>应用名称本地化/国际化</h3><p>应用名称本地化，是指同一个App的名称，在不同的语言环境下（也就是手机设备的语言设置）显示不同的名称。</p><ol><li>选中工程，按下键盘上的command + N，选择Strings File（iOS-&gt;Resource-&gt;Strings File）<br><img src="/img/iOS本地化/chooseStringFile.png" alt=""></li><li>文件名字命名为InfoPlist（必须是这个名字）<br><img src="/img/iOS本地化/createStringFile.png" alt=""></li><li>点击create后，Xcode左侧导航列表就会出现名为InfoPlist.strings的文件，如下图：<br><img src="/img/iOS本地化/infoPlistString.png" alt=""></li><li>选中InfoPlist.strings，在Xcode的File inspection（Xcode右侧文件检查器）中点击Localize，目的是选择我们需要本地化的语言，如下图：<br><img src="/img/iOS本地化/1055199-871c2853254ea8b5.png" alt=""></li><li>点击Localize后，会弹出一个对话框，展开对话框列表，发现下拉列表所展示的语言正是我们在上面配置的需要国际化的语言，选择我们需要本地化的语言，然后点击对话框的Localize按钮，如下图：<br><img src="/img/iOS本地化/1055199-034e2065ed6ea719.png" alt=""></li><li>勾选所有的语言，如下图：<br><img src="/img/iOS本地化/chooseLanguageString.png" alt=""></li><li>左侧的InfoPlist.strings 出现小箭头，点击展开，如下图：<br><img src="/img/iOS本地化/viewStringFile.png" alt=""></li><li><p>分别给不同的语言给InfoPlist.strings下的文件设置对应的名字。</p><ul><li><p>在InfoPlist.strings(english)中加入如下代码：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Localizable App Name是App在英语环境环境下显示的名称</span><br><span class="line">CFBundleDisplayName = &quot;Localizable App Name&quot;;</span><br></pre></td></tr></table></figure></li><li><p>在InfoPlist.strings(Simplified)中加入如下代码：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Localizable App Name是App在英语环境环境下显示的名称</span><br><span class="line">CFBundleDisplayName = &quot;本地化&quot;;</span><br></pre></td></tr></table></figure><p>修改App语言为简体中文，运行App模拟器显示app名称为“本地化”，如下图：<br><img src="/img/iOS本地化/appCN.png" alt=""><br>修改App语言为english，运行App模拟器显示app名称为“本地化”，如下图：<br><img src="/img/iOS本地化/appUS.png" alt=""></p></li></ul></li></ol><hr><h3 id="代码中字符串的本地化"><a href="#代码中字符串的本地化" class="headerlink" title="代码中字符串的本地化"></a>代码中字符串的本地化</h3><p>字符串本地化，就是指App内的字符串在不同的语言环境下显示不同的内容。比如，”主页”这个字符串在中文语言环境下显示“主页”，在英语环境下显示“home”。</p><ol><li>应用名称本地化一样，首先需要command + N，选择iOS -&gt; Resource -&gt; Strings File<br><img src="/img/iOS本地化/chooseStringFile.png" alt=""></li><li>文件名字命名为Localizable（必须是这个名字）<br><img src="/img/iOS本地化/stringLcocal.png" alt=""></li><li>文件创建成功，查看Xcode左侧导航列表，发现多了一个名为Localizable.strings的文件，如下图：<br><img src="/img/iOS本地化/localizableStrings.png" alt=""></li><li>选中Localizable.strings，在Xcode的File inspection（Xcode右侧文件检查器）中点击Localize，目的是选择我们需要本地化的语言，如下图：<br><img src="/img/iOS本地化/localization.png" alt=""></li><li>点击Localize后，会弹出一个对话框，展开对话框列表，发现下拉列表所展示的语言正是我们在上面配置的需要国际化的语言，选择我们需要本地化的语言，然后点击对话框的Localize按钮，如下图：<br><img src="/img/iOS本地化/localizationChoose.png" alt=""></li><li>勾选所有的语言，如下图：<br><img src="/img/iOS本地化/gouxuanLocalized.png" alt=""></li><li><p>分别给不同的语言给InfoPlist.strings下的文件设置对应的名字。</p><ul><li><p>在Localize.strings(english)中加入如下代码：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;home&quot; = &quot;home&quot;;</span><br></pre></td></tr></table></figure></li><li><p>在Localize.strings(Simplified)中加入如下代码：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;home&quot; = &quot;首页&quot;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>获取上述例子中“home”的值，代码如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *home = NSLocalizedString(@&quot;home&quot;, nil);</span><br></pre></td></tr></table></figure><ul><li>模拟器语言环境”英语”,如下图：<br><img src="/img/iOS本地化/homeUS.png" alt=""></li><li>模拟器语言环境”简体中文”,如下图：<br><img src="/img/iOS本地化/homeCN.png" alt=""></li></ul></li></ol><hr><h3 id="多人开发情况下的字符串本地化"><a href="#多人开发情况下的字符串本地化" class="headerlink" title="多人开发情况下的字符串本地化"></a>多人开发情况下的字符串本地化</h3><p>项目开发中，独立开发的还是少数。经常会有多人开发的情况，这种情况，如果多人同时操作本地化文件，极有可能会存在冲突。另一方面，我们又不希望自己的本地化文件受到对方的污染，也就是说，我们不希望对方操作我们的本地化文件。但是上面介绍的代码中字符串的本地化是使用的是默认的文件名”Localizable”,因为启动程序时，系统将根据语言加载相应的文件得到其对应的字符串文件，这个字符串可以通过系统将NSLocalizedString中的宏生成名为“Localizable.strings”的文件。那么如何让系统加载我们自己命名的本地化文件而非系统默认的Localizable.strings呢？这就是 NSLocalizedStringFromTable(&lt;#key#&gt;, &lt;#tbl#&gt;, &lt;#comment#&gt;)的用处。<br>也就是说，如果你的strings文件名字不是Localizable而是自定义的话，如VVS.strings，那么你就得使用NSLocalizedStringFromTable这个宏来读取本地化字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// key：系统根据key取字符串</span><br><span class="line">// tbl：自定义strings文件的名字</span><br><span class="line">// comment：可以不传</span><br><span class="line">NSLocalizedStringFromTable(&lt;#key#&gt;, &lt;#tbl#&gt;, &lt;#comment#&gt;)</span><br></pre></td></tr></table></figure></p><p>创建新的strings文件：<br><img src="/img/iOS本地化/duorenkaifa.png" alt=""><br>随便添加的字段：<br><img src="/img/iOS本地化/duorenkaifaCN.png" alt=""><br>调试结果：<br><img src="/img/iOS本地化/duorenkaifaCNT.png" alt=""></p><hr><h3 id="图片本地化"><a href="#图片本地化" class="headerlink" title="图片本地化"></a>图片本地化</h3><p>本地化图片，有两种方式，第一种方式和本地化代码中的字符串一样，通过NSLocalizedString(key,comment)来获取相应的字符串，然后根据这个字符串再获取图片。</p><ul><li><p>方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *imageName = NSLocalizedString(@&quot;icon&quot;, nil);</span><br><span class="line">UIImage *image = [UIImage imageNamed:imageName];</span><br><span class="line">self.imageView.image = image;</span><br></pre></td></tr></table></figure></li><li><p>方式二：</p><ol><li>先将照片添加到项目中，然后点击Localize，本文以arrow.png为例，如下图：<br> <img src="/img/iOS本地化/arrow-1.png" alt=""></li><li>点击Localize后，跳出下图，点击localize<br> <img src="/img/iOS本地化/arrow-2.png" alt=""></li><li>然后选择所有语言，如下图：<br> <img src="/img/iOS本地化/arrow-3.png" alt=""></li><li>上述案例中的arrow.png中出现三角符号，点开可以看到对应语言的arrow.png<br> <img src="/img/iOS本地化/arrow-4.png" alt=""></li><li>选中相应语言的照片，右击arrow.png-&gt;show in Finder，可以看到相对应语言的文件夹，将相对应的照片放进去即可<br> <img src="/img/iOS本地化/arrow-5.png" alt=""></li><li><p>切换不同语言查看效果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UIImageView *imageview = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];</span><br><span class="line">[self.view addSubview:imageview];</span><br><span class="line">imageview.center = self.view.center;</span><br><span class="line">//获取图标名称</span><br><span class="line">NSString *imageName = NSLocalizedString(@&quot;arrow&quot;, nil);</span><br><span class="line">[imageview setImage:[UIImage imageNamed:imageName]];</span><br></pre></td></tr></table></figure><ul><li>“英语”环境<br>  <img src="/img/iOS本地化/arrow-6.png" alt="english截图"></li><li>“简体中文”环境<br>  <img src="/img/iOS本地化/arrow-7.png" alt="简体中文截图"></li></ul></li></ol></li></ul><hr><h3 id="查看-切换本地语言"><a href="#查看-切换本地语言" class="headerlink" title="查看/切换本地语言"></a>查看/切换本地语言</h3><p>应用启动时，首先会读取NSUserDefaults中的key为AppleLanguages对应的value，该value是一个String数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSArray *languages = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;AppleLanguages&quot;];</span><br><span class="line">NSString *currentLanguage = languages.firstObject;</span><br><span class="line">NSLog(@&quot;模拟器当前语言：%@&quot;,currentLanguage);</span><br></pre></td></tr></table></figure></p><p>同理可查看语言，也可以设置语言<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 切换语言前</span><br><span class="line">NSArray *langArr1 = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;AppleLanguages&quot;];</span><br><span class="line">NSString *language1 = langArr1.firstObject;</span><br><span class="line">NSLog(@&quot;模拟器语言切换之前：%@&quot;,language1);</span><br><span class="line"></span><br><span class="line">// 切换语言</span><br><span class="line">NSArray *lans = @[@&quot;en&quot;];</span><br><span class="line">[[NSUserDefaults standardUserDefaults] setObject:lans forKey:@&quot;AppleLanguages&quot;];</span><br><span class="line"></span><br><span class="line">// 切换语言后</span><br><span class="line">NSArray *langArr2 = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;AppleLanguages&quot;];</span><br><span class="line">NSString *language2 = langArr2.firstObject;</span><br><span class="line">NSLog(@&quot;模拟器语言切换之后：%@&quot;,language2);</span><br></pre></td></tr></table></figure></p><hr><p>– <strong>完结</strong> –</p>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本地化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>3D Touch开发</title>
      <link href="/2018/07/11/3D-Touch%E5%BC%80%E5%8F%91/"/>
      <url>/2018/07/11/3D-Touch%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<h2 id="3D-Touch"><a href="#3D-Touch" class="headerlink" title="3D Touch"></a>3D Touch</h2><p><strong>3D Touch</strong> 是一种立体触控技术，被苹果称为新一代多点触控技术，是在 <strong>Apple Watch</strong> 上采用的 <strong>Force Touch</strong>，屏幕可感应不同的感压力度触控。</p><hr><h3 id="3D-Touch有三大模块："><a href="#3D-Touch有三大模块：" class="headerlink" title="3D Touch有三大模块："></a>3D Touch有三大模块：</h3><ol><li>peek and pop<br> 常用于UITableView与UICollectionView中，长按Cell会预览</li><li>Home Screen Quick Actions<br> 点击图片弹出快速入口</li><li>Force Properties</li></ol><hr><h3 id="Home-Screen-Quick-Actions开发指南"><a href="#Home-Screen-Quick-Actions开发指南" class="headerlink" title="Home Screen Quick Actions开发指南"></a>Home Screen Quick Actions开发指南</h3><p>3D Touch快速入口标签有两种添加方式：一种是静态添加，在工程中的info.plist文件中添加相关项目。项目安装就可以使用<br>另一种是动态添加，通过代码给App添加快速入口。项目运行一次后，可以唤醒标签</p><h4 id="info-plist静态添加入"><a href="#info-plist静态添加入" class="headerlink" title="info.plist静态添加入"></a>info.plist静态添加入</h4><p>静态添加入口标签不需要写代码，只需要在info.plist文件中添加相关功能设置即可。<br>在info.plist中添加如下信息：<br><img src="/img/3D-Touch/3d-touch-info.png" alt="info.plist中添加的内容"></p><p>分析一下添加的项目分别代表什么意思。<br>首先是UIApplicationShortcutItems，他是一个数组类型，数组中的每一个元素表示一个入口标签。<br>然后是Item0，这是数组中的一个元素，字典类型。在这个字典中配置各个标签的相关属性。</p><table><thead><tr><th style="text-align:center">字段名</th><th style="text-align:center">功能</th><th style="text-align:center">是否必须</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">UIApplicationShortcutItemType</td><td style="text-align:center">UIApplicationShortcutItem对象的唯一标识符</td><td style="text-align:center">true</td><td style="text-align:center">监听该项的值来判断用户是从哪一个标签进入App的，该字段的值可以为空。</td></tr><tr><td style="text-align:center">UIApplicationShortcutItemTitle</td><td style="text-align:center">UIApplicationShortcutItem对象的标题</td><td style="text-align:center">true</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">UIApplicationShortcutItemSubtitle</td><td style="text-align:center">UIApplicationShortcutItem对象的副标题</td><td style="text-align:center">false</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">UIApplicationShortcutItemIconType</td><td style="text-align:center">UIApplicationShortcutItem对象的图标类型</td><td style="text-align:center">false</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">UIApplicationShortcutItemIconFile</td><td style="text-align:center">自定义标签图片文件的路径</td><td style="text-align:center">false</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">UIApplicationShortcutItemUserInfo</td><td style="text-align:center">用户信息，是一个字典类型，可以用来传值</td><td style="text-align:center">false</td><td style="text-align:center"></td></tr></tbody></table><hr><h4 id="动态添加入口"><a href="#动态添加入口" class="headerlink" title="动态添加入口"></a>动态添加入口</h4><p>代码来添加，首先来认识三个类：</p><table><thead><tr><th style="text-align:center">类名</th><th style="text-align:center">功能描述</th></tr></thead><tbody><tr><td style="text-align:center">UIApplicationShortcutItem</td><td style="text-align:center">创建标签的类</td></tr><tr><td style="text-align:center">UIMutableApplicationShortcutItem</td><td style="text-align:center">创建可变标签类</td></tr><tr><td style="text-align:center">UIApplicationShortcutIcon</td><td style="text-align:center">创建标签icon的类</td></tr></tbody></table><p>创建一个新工程，AppDelegate中添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123;</span><br><span class="line">    if (@available(iOS 9.0, *)) &#123;</span><br><span class="line">        //创建标签</span><br><span class="line">        UIApplicationShortcutItem *item1 = [[UIApplicationShortcutItem alloc] initWithType:@&quot;Share&quot; localizedTitle:@&quot;Share&quot; localizedSubtitle:@&quot;Share&quot; icon:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeShare] userInfo:nil];</span><br><span class="line">        UIApplicationShortcutItem *item2 = [[UIApplicationShortcutItem alloc] initWithType:@&quot;详情&quot; localizedTitle:@&quot;详情&quot; localizedSubtitle:@&quot;详情&quot; icon:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeHome] userInfo:nil];</span><br><span class="line">        UIApplicationShortcutItem *item3 = [[UIApplicationShortcutItem alloc] initWithType:@&quot;测试&quot; localizedTitle:@&quot;测试&quot; localizedSubtitle:@&quot;测试&quot; icon:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeLove] userInfo:nil];</span><br><span class="line">        //将标签添加进Application的shortcutItems中。</span><br><span class="line">        NSMutableArray *itemArray = [NSMutableArray arrayWithObjects:item1,item2,item3, nil];</span><br><span class="line">        [UIApplication sharedApplication].shortcutItems = itemArray;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;设备不支持3D-Touch&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return  YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>系统提供了如下样式的标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIApplicationShortcutIconType) &#123;</span><br><span class="line">    UIApplicationShortcutIconTypeCompose,</span><br><span class="line">    UIApplicationShortcutIconTypePlay,</span><br><span class="line">    UIApplicationShortcutIconTypePause,</span><br><span class="line">    UIApplicationShortcutIconTypeAdd,</span><br><span class="line">    UIApplicationShortcutIconTypeLocation,</span><br><span class="line">    UIApplicationShortcutIconTypeSearch,</span><br><span class="line">    UIApplicationShortcutIconTypeShare,</span><br><span class="line">    UIApplicationShortcutIconTypeProhibit       NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeContact        NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeHome           NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeMarkLocation   NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeFavorite       NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeLove           NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeCloud          NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeInvitation     NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeConfirmation   NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeMail           NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeMessage        NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeDate           NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeTime           NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeCapturePhoto   NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeCaptureVideo   NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeTask           NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeTaskCompleted  NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeAlarm          NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeBookmark       NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeShuffle        NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeAudio          NS_ENUM_AVAILABLE_IOS(9_1),</span><br><span class="line">    UIApplicationShortcutIconTypeUpdate         NS_ENUM_AVAILABLE_IOS(9_1)</span><br><span class="line">&#125; NS_ENUM_AVAILABLE_IOS(9_0) __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure></p><p>系统图标不满足需求，可以使用+ (instancetype)iconWithTemplateImageName:(NSString *)templateImageName;添加自定义图片作为标签，需要注意的是：图片必须预先添加进bundle。</p><hr><h4 id="通过点击3D-Touch启动App"><a href="#通过点击3D-Touch启动App" class="headerlink" title="通过点击3D Touch启动App"></a>通过点击3D Touch启动App</h4><p>在AppDelegate中与如下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此方法的shortcutItem参数携带了从快速入口进入app时的标签参数。<br>判断shortcutItem.localizedTitle属性的值来判断是从哪一个标签进入的App。</p><hr><p>至此 <strong>3D Touch</strong>就介绍完毕了。由于技术有限，时间匆忙，难免会存在纰漏，欢迎指正</p>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2018/07/11/Prolusion/"/>
      <url>/2018/07/11/Prolusion/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MVVM 与 ReactiveCocoa</title>
      <link href="/2018/07/10/MVVM-and-RAC/"/>
      <url>/2018/07/10/MVVM-and-RAC/</url>
      <content type="html"><![CDATA[<h2 id="MVVM模式与RAC"><a href="#MVVM模式与RAC" class="headerlink" title="MVVM模式与RAC"></a>MVVM模式与RAC</h2><p>  <strong>MVVM</strong> 是 <strong>MVC</strong> 模式的一种演进，它主要解决了 <strong>ViewController</strong> 过于臃肿带来的不易维护和测试的问题。其中 <strong>ViewModel</strong> 的主要职 责是处理业务逻辑并提供 <strong>View</strong> 所需的数据，这样 <strong>VC</strong> 就不用关心业务，自然也就瘦了下来。<strong>ViewModel</strong> 只关心业务数据不关心 <strong>View</strong>，所以不会与 <strong>View</strong> 产生耦合，也就更方便进行单元测试。</p><p>  <strong>View</strong> 是一个壳，它所呈现的内容都需要由 <strong>ViewModel</strong> 来提供，而 <strong>View</strong> 又不与 <strong>ViewModel</strong> 直接沟通，这时就需要 <strong>ViewController</strong> 来做中间的协调者。<br><strong>ViewController</strong> 持有 <strong>View</strong>和 <strong>ViewModel</strong>，当 <strong>VC</strong>初始化时，会让 <strong>ViewModel</strong> 去取数据，简单来说就是调用 <strong>VM</strong> 的某个获取数据的方法。</p><p>  使用 <strong>MVVM</strong> 最舒服的姿势是搭配 <strong>ReactiveCocoa</strong>。不过它的问题在于学习成本和维护成本比较高，在小团队中或许还可以尝试，当开发人员数量较多时就很难推起来了。这也是我们今天要讲的主题：如何不借助 <strong>ReactiveCocoa</strong> 来实现 <strong>MVVM</strong>。</p><hr><p>  先从数据的获取开始说起吧。在 <strong>ReactiveCocoa</strong> 里有一个类叫「RACCommand」，它的主要作用是执行某个会改变数据的操作，然后提供获取数据的方法，跟我们想要达到的目的很像，所以可以借鉴这个思路，写一个简单的 Command。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^MGJCommandCompletionBlock)(id error, id content);</span><br><span class="line"></span><br><span class="line">// 1</span><br><span class="line">typedef void(^MGJCommandConsumeBlock)(id input, MGJCommandCompletionBlock completionHandler);</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">typedef void(^MGJCommandCancelBlock)();</span><br><span class="line"></span><br><span class="line">@interface MGJCommandResult : NSObject</span><br><span class="line">// 3</span><br><span class="line">@property (nonatomic) NSError *error;</span><br><span class="line">// 4</span><br><span class="line">@property (nonatomic) id content;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface MGJCommand : NSObject</span><br><span class="line"></span><br><span class="line">// 5</span><br><span class="line">@property (nonatomic, readonly) BOOL executing;</span><br><span class="line">// 6</span><br><span class="line">@property (nonatomic, readonly) MGJCommandResult *result;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithConsumeHandler:(MGJCommandConsumeBlock )consumeHandler;</span><br><span class="line">// 7</span><br><span class="line">- (instancetype)initWithConsumeHandler:(MGJCommandConsumeBlock )consumeHandler cancelHandler:(MGJCommandCancelBlock )cancelHandler;</span><br><span class="line"></span><br><span class="line">// 8</span><br><span class="line">- (void)execute:(id)input;</span><br><span class="line">// 9</span><br><span class="line">- (void)cancel;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>1.<strong>input</strong>是外部传过来的值，比如 user_id，当拿到数据后，调用下 <strong>completionHandler</strong>，这样 <strong>result</strong> 属性就会变化<br>2.有些操作，如 <strong>http</strong> 请求，需要手动取消<br>3.单独把 <strong>error</strong>作为一个属性放出来，是因为很多数据请求操作都可能出错，当出错后，只需改变这个 <strong>error</strong> 属性即可。<br>4.<strong>content</strong> 存放了这个 <strong>Command</strong> 的数据处理结果。<br>5.标识了这个 <strong>Command</strong> 目前的运行状态，比如可以根据这个状态来显示 <strong>loading</strong>。<br>6.每次 <strong>Command</strong> 执行完一个任务后，<strong>result</strong> 都会改变，外部可以 <strong>KVO</strong> 这个 <strong>result</strong>，然后就可以实时获取最新的结果了。<br>7.<strong>Command</strong> 的执行逻辑，如果实现了 <strong>cancelHandler</strong> 的话，外部调用 <strong>cancel</strong>，这个 <strong>Handler</strong> 就会被触发。<br>8.外部可以调用这个方法来触发 <strong>Command</strong> 的执行，同时可以传一个参数进来。<br>9.外部可以调用这个方法来取消 <strong>Command</strong> 的执行。</p><p>实现起来也蛮简单的，这里就不多说了。用起来大概是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SomeViewModel.m</span><br><span class="line">@weakify(self);</span><br><span class="line">self.followCommand = [[MGJCommand alloc] initWithConsumeHandler:^(id input, MGJCommandCompletionBlock completionHandler) &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    [FollowRequest getFollowList:(NSDictionary *)input success:^(NSArray *users) &#123;</span><br><span class="line">        self.usersToFollow = users;</span><br><span class="line">        completionHandler(nil, kFollowExpertSearchSucceedSignal);</span><br><span class="line">    &#125; failure:^(StatusEntity *error) &#123;</span><br><span class="line">        completionHandler(error, nil);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>在 <strong>ViewController</strong> 里的用法大概像这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SomeViewController.m</span><br><span class="line"></span><br><span class="line">- (void)didTapFollowButton:(UIButton *)button</span><br><span class="line">&#123;</span><br><span class="line">// 根据 button 找到 userID</span><br><span class="line">[self.viewModel.followCommand execute:userID];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就是这样，<strong>VC</strong> 本身不处理业务逻辑，都交给 <strong>ViewModel</strong> 去处理，而这些数据请求的结果处理又有不同的处理方式。</p><hr><h3 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a>Delegate</h3><p>当 <strong>ViewModel</strong> 拿到数据后，可以把结果以 <strong>Delegate</strong> 的方式通知 <strong>VC</strong>，就像这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// SomeViewController.m</span><br><span class="line"></span><br><span class="line">- (void)didFollowUserWithResult:(id)result</span><br><span class="line">&#123;</span><br><span class="line">self.followButton.enabled = YES;</span><br><span class="line">[self.followButton doSomeAnimation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样做的好处是比较符合苹果既有的设计模式，而且也可以通过查看 <strong>Delegate</strong> 协议来知道 <strong>VM</strong> 暴露了哪些接口供外部使用。</p><p>不过这种方法少了点灵活性，比如需要联合多个属性的变化来做一些事情时，处理起来就会比较麻烦，这也是 <strong>RAC</strong> 强大的地方。</p><hr><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p><strong>RAC</strong> 是基于 <strong>KVO</strong> 构建的，所以也可以用 <strong>KVO</strong> 来让 <strong>VC</strong> 获取 <strong>VM</strong> 的变化。<br>但我们都知道 <strong>KVO</strong> 的槽点比较多，比如使用起来不方便，用完还要记得移除等。这里可以使用 Facebook 开源的 KVOController，它比较好的处理了 <strong>KVO</strong> 存在的一些问题，同时又能发挥 <strong>KVO</strong> 带来的便捷性。<br>有了它我们就能在一个地方把 VM 的更新处理掉了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleViewModelUpdate</span><br><span class="line">&#123;</span><br><span class="line">[self.KVOController observe:self.viewModel keyPath:@&quot;followCommand.result&quot; options:NSKeyValueObservingOptionInitial|NSKeyValueObservingOptionNew block:^(id observer, id target, NSDictionary *change) &#123;</span><br><span class="line">id newValue = change[NSKeyValueChangeNewKey];</span><br><span class="line">// doSomething with the newValue</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 对 VM 其他 keyPath 的处理也都可以放到这里</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果觉得这样的写法还是太麻烦，可以做一层简单的封装，使用起来就像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleViewModelUpdate</span><br><span class="line">&#123;</span><br><span class="line">[self observe:self.viewModel keyPath:@&quot;followCommand.result&quot; block: ^(id newValue)&#123;</span><br><span class="line">// use newValue to update view</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是会好一点，使用 <strong>KVO</strong> 比 <strong>Delegate</strong> 好的一点是不用再额外声明协议和方法，而且支持 <strong>block</strong>，使用起来也会方便些。<br>对于像 <strong>error</strong> 这样很多操作都会产生同样结果的场景，可以单独拿出来，作为 <strong>ViewModel</strong> 的一个属性，使用时，直接 <strong>KVO</strong> 这个属性即可。</p><hr><h3 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h3><p>如果不涉及到 <strong>TableView</strong> 等会出现复用场景的地方，<strong>MVVM</strong> 使用起来还是比较方便的。如果有了 <strong>TableView</strong>，又要做一些额外的处理。</p><p>一般来说，<strong>VC</strong> 可以带一个 <strong>VM</strong>，那如果出现 <strong>Cell</strong> 时怎么办，<strong>Cell</strong> 里又包含了按钮，按钮又需要数据请求又怎么处理？这些都是比较常见的场景，也可以通过 <strong>MVVM</strong> 来解决。</p><p>我们知道 <strong>VM</strong> 的职责是为 <strong>View</strong> 提供数据支持，<strong>Cell</strong> 也是一个 <strong>View</strong>，那么为 <strong>Cell</strong> 配备一个 <strong>VM</strong> 不就可以了么。</p><p>这样的话，<strong>VC</strong> 的 <strong>VM</strong> 需要包含一个数组，里面的元素是 <strong>CellVM</strong>，使用起来就像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SomeViewController.m</span><br><span class="line"></span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;Cell&quot; forIndexPath:indexPath];</span><br><span class="line">cell.viewModel = self.viewModel.cellViewModels[indexPath.row];</span><br><span class="line"></span><br><span class="line">// cell 可能会用到 cellVM 里的 Command，所以在这里处理 command 的执行结果</span><br><span class="line">[self observe:cell keyPath:@&quot;likeCommand.result&quot; block: ^(id newValue)&#123;</span><br><span class="line">// update cell after like</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">return cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然仅仅如此是不够的，我们需要找个恰当的时机把 <strong>KVO</strong> 移除，避免多次监听。<strong>UITableViewDelegate</strong> 里的这个方法就很适合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// SomeViewController.m</span><br><span class="line"></span><br><span class="line">- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">[self unobserve:cell keyPath:@&quot;likeCommand.result&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这里也要讲究一个平衡，如果 <strong>Cell</strong> 的类型比较多，且涉及 <strong>Command</strong> 的地方不多，只是做呈现方面的工作，直接使用 <strong>Entity</strong> 会更方便。</p><hr><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol><li><strong>ViewController</strong> 尽量不涉及业务逻辑，让 <strong>ViewModel</strong> 去做这些事情。</li><li><strong>ViewController</strong> 只是一个中间人，接收 <strong>View</strong> 的事件、调用 <strong>ViewModel</strong> 的方法、响应 <strong>ViewModel</strong> 的变化。</li><li><strong>ViewModel</strong> 不能包含 <strong>View</strong>，不然就跟 <strong>View</strong> 产生了耦合，不方便复用和测试。</li><li><strong>ViewModel</strong> 之间可以有依赖。</li><li><strong>ViewModel</strong> 避免过于臃肿，不然维护起来也是个问题。<br><strong>MVVM</strong> 并不复杂，跟 <strong>MVC</strong> 也是兼容的，只是多了一个 <strong>ViewModel</strong> 层，但就是这么一个小改动，就能让代码变得更加容易阅读和维护，不妨试一下吧。</li></ol><hr><p>以上为记录贴</p>]]></content>
      
      <categories>
          
          <category> iOS开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
