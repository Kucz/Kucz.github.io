{"meta":{"title":"閃閃星茫°夜空〃博客","subtitle":"日日行，不怕千万里；常常做，不怕千万事。——《格言联璧·处事》","description":"谁不会休息，谁就不会工作。——列宁","author":"閃閃星茫°夜空〃","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2016-04-20T20:48:33.000Z","updated":"2018-07-11T02:26:53.213Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"自我介绍新人一枚，多多关照&nbsp;&nbsp;&nbsp;&nbsp;新人一枚，多多关照&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新人一枚，多多关照&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重要的事情说三遍! 其他资料以后补充😊"},{"title":"分类","date":"2018-01-04T16:00:00.000Z","updated":"2018-07-11T01:27:20.451Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-01-04T16:00:00.000Z","updated":"2018-07-11T01:27:14.787Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"iOS App本地化","slug":"iOS-App本地化","date":"2018-07-12T01:26:40.000Z","updated":"2018-07-12T03:00:13.829Z","comments":false,"path":"2018/07/12/iOS-App本地化/","link":"","permalink":"http://yoursite.com/2018/07/12/iOS-App本地化/","excerpt":"App本地化语言本地化，又叫做语言国际化。是指根据用户操作系统的语言设置，自动将应用程序的语言设置为和用户操作系统语言一致的语言。往往一些应用程序需要提供给多个国家的人群使用，或者一个国家有多种语言，这就要求应用程序所展示的文字、图片等信息，能够让讲不同语言的用户读懂、看懂。进而提出为同一个应用程序适配多种语言，也即是国际化。语言国际化之所以又叫做语言本地化，这是站在每个用户的角度而言的，是指能够让用户本地、本土人群能够看懂的语言信息，顾名思义，语言本地化。","text":"App本地化语言本地化，又叫做语言国际化。是指根据用户操作系统的语言设置，自动将应用程序的语言设置为和用户操作系统语言一致的语言。往往一些应用程序需要提供给多个国家的人群使用，或者一个国家有多种语言，这就要求应用程序所展示的文字、图片等信息，能够让讲不同语言的用户读懂、看懂。进而提出为同一个应用程序适配多种语言，也即是国际化。语言国际化之所以又叫做语言本地化，这是站在每个用户的角度而言的，是指能够让用户本地、本土人群能够看懂的语言信息，顾名思义，语言本地化。 本文从以下六个方面入手 配置需要国际化的语言（国际化的准备工作） App名称本地化 代码中字符串本地化 多人开发情况下的字符串本地化 图片本地化（两种方式两种方式） 查看/切换本地语言 配置需要国际化 选中project-&gt;Info-&gt;Localizations，然后点击”+”，添加需要国际化/本地化的语言，如下图（默认需要勾选Use Base Internationalization）： 以添加简体中文为例： 添加简体中文后弹出如下对话框，直接点击finish，如下图： 添加其他语言同上述流程 应用名称本地化/国际化应用名称本地化，是指同一个App的名称，在不同的语言环境下（也就是手机设备的语言设置）显示不同的名称。 选中工程，按下键盘上的command + N，选择Strings File（iOS-&gt;Resource-&gt;Strings File） 文件名字命名为InfoPlist（必须是这个名字） 点击create后，Xcode左侧导航列表就会出现名为InfoPlist.strings的文件，如下图： 选中InfoPlist.strings，在Xcode的File inspection（Xcode右侧文件检查器）中点击Localize，目的是选择我们需要本地化的语言，如下图： 点击Localize后，会弹出一个对话框，展开对话框列表，发现下拉列表所展示的语言正是我们在上面配置的需要国际化的语言，选择我们需要本地化的语言，然后点击对话框的Localize按钮，如下图： 勾选所有的语言，如下图： 左侧的InfoPlist.strings 出现小箭头，点击展开，如下图： 分别给不同的语言给InfoPlist.strings下的文件设置对应的名字。 在InfoPlist.strings(english)中加入如下代码： 12// Localizable App Name是App在英语环境环境下显示的名称CFBundleDisplayName = &quot;Localizable App Name&quot;; 在InfoPlist.strings(Simplified)中加入如下代码： 12// Localizable App Name是App在英语环境环境下显示的名称CFBundleDisplayName = &quot;本地化&quot;; 修改App语言为简体中文，运行App模拟器显示app名称为“本地化”，如下图：修改App语言为english，运行App模拟器显示app名称为“本地化”，如下图： 代码中字符串的本地化字符串本地化，就是指App内的字符串在不同的语言环境下显示不同的内容。比如，”主页”这个字符串在中文语言环境下显示“主页”，在英语环境下显示“home”。 应用名称本地化一样，首先需要command + N，选择iOS -&gt; Resource -&gt; Strings File 文件名字命名为Localizable（必须是这个名字） 文件创建成功，查看Xcode左侧导航列表，发现多了一个名为Localizable.strings的文件，如下图： 选中Localizable.strings，在Xcode的File inspection（Xcode右侧文件检查器）中点击Localize，目的是选择我们需要本地化的语言，如下图： 点击Localize后，会弹出一个对话框，展开对话框列表，发现下拉列表所展示的语言正是我们在上面配置的需要国际化的语言，选择我们需要本地化的语言，然后点击对话框的Localize按钮，如下图： 勾选所有的语言，如下图： 分别给不同的语言给InfoPlist.strings下的文件设置对应的名字。 在Localize.strings(english)中加入如下代码： 1&quot;home&quot; = &quot;home&quot;; 在Localize.strings(Simplified)中加入如下代码： 1&quot;home&quot; = &quot;首页&quot;; 获取上述例子中“home”的值，代码如下： 1NSString *home = NSLocalizedString(@&quot;home&quot;, nil); 模拟器语言环境”英语”,如下图： 模拟器语言环境”简体中文”,如下图： 多人开发情况下的字符串本地化项目开发中，独立开发的还是少数。经常会有多人开发的情况，这种情况，如果多人同时操作本地化文件，极有可能会存在冲突。另一方面，我们又不希望自己的本地化文件受到对方的污染，也就是说，我们不希望对方操作我们的本地化文件。但是上面介绍的代码中字符串的本地化是使用的是默认的文件名”Localizable”,因为启动程序时，系统将根据语言加载相应的文件得到其对应的字符串文件，这个字符串可以通过系统将NSLocalizedString中的宏生成名为“Localizable.strings”的文件。那么如何让系统加载我们自己命名的本地化文件而非系统默认的Localizable.strings呢？这就是 NSLocalizedStringFromTable(&lt;#key#&gt;, &lt;#tbl#&gt;, &lt;#comment#&gt;)的用处。也就是说，如果你的strings文件名字不是Localizable而是自定义的话，如VVS.strings，那么你就得使用NSLocalizedStringFromTable这个宏来读取本地化字符串。1234// key：系统根据key取字符串// tbl：自定义strings文件的名字// comment：可以不传NSLocalizedStringFromTable(&lt;#key#&gt;, &lt;#tbl#&gt;, &lt;#comment#&gt;) 创建新的strings文件：随便添加的字段：调试结果： 图片本地化本地化图片，有两种方式，第一种方式和本地化代码中的字符串一样，通过NSLocalizedString(key,comment)来获取相应的字符串，然后根据这个字符串再获取图片。 方式一： 123NSString *imageName = NSLocalizedString(@&quot;icon&quot;, nil);UIImage *image = [UIImage imageNamed:imageName];self.imageView.image = image; 方式二： 待补充 查看/切换本地语言应用启动时，首先会读取NSUserDefaults中的key为AppleLanguages对应的value，该value是一个String数组123NSArray *languages = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;AppleLanguages&quot;];NSString *currentLanguage = languages.firstObject;NSLog(@&quot;模拟器当前语言：%@&quot;,currentLanguage); 同理可查看语言，也可以设置语言12345678910111213// 切换语言前NSArray *langArr1 = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;AppleLanguages&quot;];NSString *language1 = langArr1.firstObject;NSLog(@&quot;模拟器语言切换之前：%@&quot;,language1);// 切换语言NSArray *lans = @[@&quot;en&quot;];[[NSUserDefaults standardUserDefaults] setObject:lans forKey:@&quot;AppleLanguages&quot;];// 切换语言后NSArray *langArr2 = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;AppleLanguages&quot;];NSString *language2 = langArr2.firstObject;NSLog(@&quot;模拟器语言切换之后：%@&quot;,language2); – 完结 –","categories":[],"tags":[]},{"title":"3D Touch开发","slug":"3D-Touch开发","date":"2018-07-11T07:18:44.000Z","updated":"2018-07-11T08:16:59.792Z","comments":true,"path":"2018/07/11/3D-Touch开发/","link":"","permalink":"http://yoursite.com/2018/07/11/3D-Touch开发/","excerpt":"3D Touch3D Touch 是一种立体触控技术，被苹果称为新一代多点触控技术，是在 Apple Watch 上采用的 Force Touch，屏幕可感应不同的感压力度触控。","text":"3D Touch3D Touch 是一种立体触控技术，被苹果称为新一代多点触控技术，是在 Apple Watch 上采用的 Force Touch，屏幕可感应不同的感压力度触控。 3D Touch有三大模块： peek and pop 常用于UITableView与UICollectionView中，长按Cell会预览 Home Screen Quick Actions 点击图片弹出快速入口 Force Properties Home Screen Quick Actions开发指南3D Touch快速入口标签有两种添加方式：一种是静态添加，在工程中的info.plist文件中添加相关项目。项目安装就可以使用另一种是动态添加，通过代码给App添加快速入口。项目运行一次后，可以唤醒标签 info.plist静态添加入静态添加入口标签不需要写代码，只需要在info.plist文件中添加相关功能设置即可。在info.plist中添加如下信息： 分析一下添加的项目分别代表什么意思。首先是UIApplicationShortcutItems，他是一个数组类型，数组中的每一个元素表示一个入口标签。然后是Item0，这是数组中的一个元素，字典类型。在这个字典中配置各个标签的相关属性。 字段名 功能 是否必须 备注 UIApplicationShortcutItemType UIApplicationShortcutItem对象的唯一标识符 true 监听该项的值来判断用户是从哪一个标签进入App的，该字段的值可以为空。 UIApplicationShortcutItemTitle UIApplicationShortcutItem对象的标题 true UIApplicationShortcutItemSubtitle UIApplicationShortcutItem对象的副标题 false UIApplicationShortcutItemIconType UIApplicationShortcutItem对象的图标类型 false UIApplicationShortcutItemIconFile 自定义标签图片文件的路径 false UIApplicationShortcutItemUserInfo 用户信息，是一个字典类型，可以用来传值 false 动态添加入口代码来添加，首先来认识三个类： 类名 功能描述 UIApplicationShortcutItem 创建标签的类 UIMutableApplicationShortcutItem 创建可变标签类 UIApplicationShortcutIcon 创建标签icon的类 创建一个新工程，AppDelegate中添加如下代码：1234567891011121314- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; if (@available(iOS 9.0, *)) &#123; //创建标签 UIApplicationShortcutItem *item1 = [[UIApplicationShortcutItem alloc] initWithType:@&quot;Share&quot; localizedTitle:@&quot;Share&quot; localizedSubtitle:@&quot;Share&quot; icon:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeShare] userInfo:nil]; UIApplicationShortcutItem *item2 = [[UIApplicationShortcutItem alloc] initWithType:@&quot;详情&quot; localizedTitle:@&quot;详情&quot; localizedSubtitle:@&quot;详情&quot; icon:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeHome] userInfo:nil]; UIApplicationShortcutItem *item3 = [[UIApplicationShortcutItem alloc] initWithType:@&quot;测试&quot; localizedTitle:@&quot;测试&quot; localizedSubtitle:@&quot;测试&quot; icon:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeLove] userInfo:nil]; //将标签添加进Application的shortcutItems中。 NSMutableArray *itemArray = [NSMutableArray arrayWithObjects:item1,item2,item3, nil]; [UIApplication sharedApplication].shortcutItems = itemArray; &#125;else&#123; NSLog(@&quot;设备不支持3D-Touch&quot;); &#125; return YES;&#125; 系统提供了如下样式的标签：12345678910111213141516171819202122232425262728293031typedef NS_ENUM(NSInteger, UIApplicationShortcutIconType) &#123; UIApplicationShortcutIconTypeCompose, UIApplicationShortcutIconTypePlay, UIApplicationShortcutIconTypePause, UIApplicationShortcutIconTypeAdd, UIApplicationShortcutIconTypeLocation, UIApplicationShortcutIconTypeSearch, UIApplicationShortcutIconTypeShare, UIApplicationShortcutIconTypeProhibit NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeContact NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeHome NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeMarkLocation NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeFavorite NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeLove NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeCloud NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeInvitation NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeConfirmation NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeMail NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeMessage NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeDate NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeTime NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeCapturePhoto NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeCaptureVideo NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeTask NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeTaskCompleted NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeAlarm NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeBookmark NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeShuffle NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeAudio NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeUpdate NS_ENUM_AVAILABLE_IOS(9_1)&#125; NS_ENUM_AVAILABLE_IOS(9_0) __TVOS_PROHIBITED; 系统图标不满足需求，可以使用+ (instancetype)iconWithTemplateImageName:(NSString *)templateImageName;添加自定义图片作为标签，需要注意的是：图片必须预先添加进bundle。 通过点击3D Touch启动App在AppDelegate中与如下方法123-(void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler&#123;&#125; 此方法的shortcutItem参数携带了从快速入口进入app时的标签参数。判断shortcutItem.localizedTitle属性的值来判断是从哪一个标签进入的App。 至此 3D Touch就介绍完毕了。由于技术有限，时间匆忙，难免会存在纰漏，欢迎指正","categories":[{"name":"IOS开发","slug":"IOS开发","permalink":"http://yoursite.com/categories/IOS开发/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"第一篇博客","slug":"Prolusion","date":"2018-07-11T02:32:01.000Z","updated":"2018-07-11T08:14:39.905Z","comments":true,"path":"2018/07/11/Prolusion/","link":"","permalink":"http://yoursite.com/2018/07/11/Prolusion/","excerpt":"","text":"","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"MVVM 与 ReactiveCocoa","slug":"MVVM-and-RAC","date":"2018-07-10T05:46:58.000Z","updated":"2018-07-11T08:16:51.811Z","comments":true,"path":"2018/07/10/MVVM-and-RAC/","link":"","permalink":"http://yoursite.com/2018/07/10/MVVM-and-RAC/","excerpt":"MVVM模式与RAC MVVM 是 MVC 模式的一种演进，它主要解决了 ViewController 过于臃肿带来的不易维护和测试的问题。其中 ViewModel 的主要职 责是处理业务逻辑并提供 View 所需的数据，这样 VC 就不用关心业务，自然也就瘦了下来。ViewModel 只关心业务数据不关心 View，所以不会与 View 产生耦合，也就更方便进行单元测试。","text":"MVVM模式与RAC MVVM 是 MVC 模式的一种演进，它主要解决了 ViewController 过于臃肿带来的不易维护和测试的问题。其中 ViewModel 的主要职 责是处理业务逻辑并提供 View 所需的数据，这样 VC 就不用关心业务，自然也就瘦了下来。ViewModel 只关心业务数据不关心 View，所以不会与 View 产生耦合，也就更方便进行单元测试。 View 是一个壳，它所呈现的内容都需要由 ViewModel 来提供，而 View 又不与 ViewModel 直接沟通，这时就需要 ViewController 来做中间的协调者。ViewController 持有 View和 ViewModel，当 VC初始化时，会让 ViewModel 去取数据，简单来说就是调用 VM 的某个获取数据的方法。 使用 MVVM 最舒服的姿势是搭配 ReactiveCocoa。不过它的问题在于学习成本和维护成本比较高，在小团队中或许还可以尝试，当开发人员数量较多时就很难推起来了。这也是我们今天要讲的主题：如何不借助 ReactiveCocoa 来实现 MVVM。 先从数据的获取开始说起吧。在 ReactiveCocoa 里有一个类叫「RACCommand」，它的主要作用是执行某个会改变数据的操作，然后提供获取数据的方法，跟我们想要达到的目的很像，所以可以借鉴这个思路，写一个简单的 Command。 12345678910111213141516171819202122232425262728293031typedef void(^MGJCommandCompletionBlock)(id error, id content);// 1typedef void(^MGJCommandConsumeBlock)(id input, MGJCommandCompletionBlock completionHandler);// 2typedef void(^MGJCommandCancelBlock)();@interface MGJCommandResult : NSObject// 3@property (nonatomic) NSError *error;// 4@property (nonatomic) id content;@end@interface MGJCommand : NSObject// 5@property (nonatomic, readonly) BOOL executing;// 6@property (nonatomic, readonly) MGJCommandResult *result;- (instancetype)initWithConsumeHandler:(MGJCommandConsumeBlock )consumeHandler;// 7- (instancetype)initWithConsumeHandler:(MGJCommandConsumeBlock )consumeHandler cancelHandler:(MGJCommandCancelBlock )cancelHandler;// 8- (void)execute:(id)input;// 9- (void)cancel;@end 1.input是外部传过来的值，比如 user_id，当拿到数据后，调用下 completionHandler，这样 result 属性就会变化2.有些操作，如 http 请求，需要手动取消3.单独把 error作为一个属性放出来，是因为很多数据请求操作都可能出错，当出错后，只需改变这个 error 属性即可。4.content 存放了这个 Command 的数据处理结果。5.标识了这个 Command 目前的运行状态，比如可以根据这个状态来显示 loading。6.每次 Command 执行完一个任务后，result 都会改变，外部可以 KVO 这个 result，然后就可以实时获取最新的结果了。7.Command 的执行逻辑，如果实现了 cancelHandler 的话，外部调用 cancel，这个 Handler 就会被触发。8.外部可以调用这个方法来触发 Command 的执行，同时可以传一个参数进来。9.外部可以调用这个方法来取消 Command 的执行。 实现起来也蛮简单的，这里就不多说了。用起来大概是这样： 1234567891011// SomeViewModel.m@weakify(self);self.followCommand = [[MGJCommand alloc] initWithConsumeHandler:^(id input, MGJCommandCompletionBlock completionHandler) &#123; @strongify(self); [FollowRequest getFollowList:(NSDictionary *)input success:^(NSArray *users) &#123; self.usersToFollow = users; completionHandler(nil, kFollowExpertSearchSucceedSignal); &#125; failure:^(StatusEntity *error) &#123; completionHandler(error, nil); &#125;];&#125;]; 在 ViewController 里的用法大概像这样1234567// SomeViewController.m- (void)didTapFollowButton:(UIButton *)button&#123; // 根据 button 找到 userID [self.viewModel.followCommand execute:userID];&#125; 就是这样，VC 本身不处理业务逻辑，都交给 ViewModel 去处理，而这些数据请求的结果处理又有不同的处理方式。 Delegate当 ViewModel 拿到数据后，可以把结果以 Delegate 的方式通知 VC，就像这样1234567// SomeViewController.m- (void)didFollowUserWithResult:(id)result&#123; self.followButton.enabled = YES; [self.followButton doSomeAnimation];&#125; 这样做的好处是比较符合苹果既有的设计模式，而且也可以通过查看 Delegate 协议来知道 VM 暴露了哪些接口供外部使用。 不过这种方法少了点灵活性，比如需要联合多个属性的变化来做一些事情时，处理起来就会比较麻烦，这也是 RAC 强大的地方。 KVORAC 是基于 KVO 构建的，所以也可以用 KVO 来让 VC 获取 VM 的变化。但我们都知道 KVO 的槽点比较多，比如使用起来不方便，用完还要记得移除等。这里可以使用 Facebook 开源的 KVOController，它比较好的处理了 KVO 存在的一些问题，同时又能发挥 KVO 带来的便捷性。有了它我们就能在一个地方把 VM 的更新处理掉了123456789- (void)handleViewModelUpdate&#123; [self.KVOController observe:self.viewModel keyPath:@&quot;followCommand.result&quot; options:NSKeyValueObservingOptionInitial|NSKeyValueObservingOptionNew block:^(id observer, id target, NSDictionary *change) &#123; id newValue = change[NSKeyValueChangeNewKey]; // doSomething with the newValue &#125;]; // 对 VM 其他 keyPath 的处理也都可以放到这里&#125; 如果觉得这样的写法还是太麻烦，可以做一层简单的封装，使用起来就像这样 123456- (void)handleViewModelUpdate&#123; [self observe:self.viewModel keyPath:@&quot;followCommand.result&quot; block: ^(id newValue)&#123; // use newValue to update view &#125;];&#125; 是不是会好一点，使用 KVO 比 Delegate 好的一点是不用再额外声明协议和方法，而且支持 block，使用起来也会方便些。对于像 error 这样很多操作都会产生同样结果的场景，可以单独拿出来，作为 ViewModel 的一个属性，使用时，直接 KVO 这个属性即可。 细节处理如果不涉及到 TableView 等会出现复用场景的地方，MVVM 使用起来还是比较方便的。如果有了 TableView，又要做一些额外的处理。 一般来说，VC 可以带一个 VM，那如果出现 Cell 时怎么办，Cell 里又包含了按钮，按钮又需要数据请求又怎么处理？这些都是比较常见的场景，也可以通过 MVVM 来解决。 我们知道 VM 的职责是为 View 提供数据支持，Cell 也是一个 View，那么为 Cell 配备一个 VM 不就可以了么。 这样的话，VC 的 VM 需要包含一个数组，里面的元素是 CellVM，使用起来就像这样 1234567891011121314// SomeViewController.m- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;Cell&quot; forIndexPath:indexPath]; cell.viewModel = self.viewModel.cellViewModels[indexPath.row]; // cell 可能会用到 cellVM 里的 Command，所以在这里处理 command 的执行结果 [self observe:cell keyPath:@&quot;likeCommand.result&quot; block: ^(id newValue)&#123; // update cell after like &#125;]; return cell&#125; 当然仅仅如此是不够的，我们需要找个恰当的时机把 KVO 移除，避免多次监听。UITableViewDelegate 里的这个方法就很适合。 123456// SomeViewController.m- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath&#123; [self unobserve:cell keyPath:@&quot;likeCommand.result&quot;];&#125; 不过这里也要讲究一个平衡，如果 Cell 的类型比较多，且涉及 Command 的地方不多，只是做呈现方面的工作，直接使用 Entity 会更方便。 Tips ViewController 尽量不涉及业务逻辑，让 ViewModel 去做这些事情。 ViewController 只是一个中间人，接收 View 的事件、调用 ViewModel 的方法、响应 ViewModel 的变化。 ViewModel 不能包含 View，不然就跟 View 产生了耦合，不方便复用和测试。 ViewModel 之间可以有依赖。 ViewModel 避免过于臃肿，不然维护起来也是个问题。MVVM 并不复杂，跟 MVC 也是兼容的，只是多了一个 ViewModel 层，但就是这么一个小改动，就能让代码变得更加容易阅读和维护，不妨试一下吧。 以上为记录贴","categories":[{"name":"IOS开发","slug":"IOS开发","permalink":"http://yoursite.com/categories/IOS开发/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]}]}