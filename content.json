{"meta":{"title":"閃閃星茫°夜空〃博客","subtitle":"日日行，不怕千万里；常常做，不怕千万事。——《格言联璧·处事》","description":"谁不会休息，谁就不会工作。——列宁","author":"閃閃星茫°夜空〃","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2016-04-20T20:48:33.000Z","updated":"2018-07-16T08:36:15.530Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"自我介绍新人一枚，多多关照&nbsp;&nbsp;&nbsp;&nbsp; 新人一枚，多多关照&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新人一枚，多多关照&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重要的事情说三遍! 其他资料以后补充😊 友情链接文藝学生-Android"},{"title":"分类","date":"2018-01-04T16:00:00.000Z","updated":"2018-07-11T01:27:20.451Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-01-04T16:00:00.000Z","updated":"2018-07-11T01:27:14.787Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"真机调试包","slug":"真机调试包","date":"2018-07-14T03:33:30.000Z","updated":"2018-07-16T10:35:39.127Z","comments":true,"path":"2018/07/14/真机调试包/","link":"","permalink":"http://yoursite.com/2018/07/14/真机调试包/","excerpt":"","text":"真机包路径在Finder状态下前往文件夹，快捷键： shift+command+G填写路径: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 11.4(15F79)下载 11.2下载 11.1下载 11.0下载 10.3下载 10.2下载 10.1下载 10.0下载 9.3下载 9.2下载 9.1下载 9.0下载 8.4下载 8.3下载 8.2下载 8.1下载 8.0下载 撒花完结","categories":[{"name":"IOS开发","slug":"IOS开发","permalink":"http://yoursite.com/categories/IOS开发/"}],"tags":[{"name":"真机调试包","slug":"真机调试包","permalink":"http://yoursite.com/tags/真机调试包/"}]},{"title":"iOS App本地化","slug":"iOS-App本地化","date":"2018-07-12T01:26:40.000Z","updated":"2018-07-16T08:06:33.505Z","comments":true,"path":"2018/07/12/iOS-App本地化/","link":"","permalink":"http://yoursite.com/2018/07/12/iOS-App本地化/","excerpt":"","text":"App本地化语言本地化，又叫做语言国际化。是指根据用户操作系统的语言设置，自动将应用程序的语言设置为和用户操作系统语言一致的语言。往往一些应用程序需要提供给多个国家的人群使用，或者一个国家有多种语言，这就要求应用程序所展示的文字、图片等信息，能够让讲不同语言的用户读懂、看懂。进而提出为同一个应用程序适配多种语言，也即是国际化。语言国际化之所以又叫做语言本地化，这是站在每个用户的角度而言的，是指能够让用户本地、本土人群能够看懂的语言信息，顾名思义，语言本地化。 本文从以下六个方面入手 配置需要国际化的语言（国际化的准备工作） App名称本地化 代码中字符串本地化 多人开发情况下的字符串本地化 图片本地化（两种方式两种方式） 查看/切换本地语言 配置需要国际化 选中project-&gt;Info-&gt;Localizations，然后点击”+”，添加需要国际化/本地化的语言，如下图（默认需要勾选Use Base Internationalization）： 以添加简体中文为例： 添加简体中文后弹出如下对话框，直接点击finish，如下图： 添加其他语言同上述流程 应用名称本地化/国际化应用名称本地化，是指同一个App的名称，在不同的语言环境下（也就是手机设备的语言设置）显示不同的名称。 选中工程，按下键盘上的command + N，选择Strings File（iOS-&gt;Resource-&gt;Strings File） 文件名字命名为InfoPlist（必须是这个名字） 点击create后，Xcode左侧导航列表就会出现名为InfoPlist.strings的文件，如下图： 选中InfoPlist.strings，在Xcode的File inspection（Xcode右侧文件检查器）中点击Localize，目的是选择我们需要本地化的语言，如下图： 点击Localize后，会弹出一个对话框，展开对话框列表，发现下拉列表所展示的语言正是我们在上面配置的需要国际化的语言，选择我们需要本地化的语言，然后点击对话框的Localize按钮，如下图： 勾选所有的语言，如下图： 左侧的InfoPlist.strings 出现小箭头，点击展开，如下图： 分别给不同的语言给InfoPlist.strings下的文件设置对应的名字。 在InfoPlist.strings(english)中加入如下代码： 12// Localizable App Name是App在英语环境环境下显示的名称CFBundleDisplayName = \"Localizable App Name\"; 在InfoPlist.strings(Simplified)中加入如下代码： 12// Localizable App Name是App在英语环境环境下显示的名称CFBundleDisplayName = \"本地化\"; 修改App语言为简体中文，运行App模拟器显示app名称为“本地化”，如下图：修改App语言为english，运行App模拟器显示app名称为“本地化”，如下图： 代码中字符串的本地化字符串本地化，就是指App内的字符串在不同的语言环境下显示不同的内容。比如，”主页”这个字符串在中文语言环境下显示“主页”，在英语环境下显示“home”。 应用名称本地化一样，首先需要command + N，选择iOS -&gt; Resource -&gt; Strings File 文件名字命名为Localizable（必须是这个名字） 文件创建成功，查看Xcode左侧导航列表，发现多了一个名为Localizable.strings的文件，如下图： 选中Localizable.strings，在Xcode的File inspection（Xcode右侧文件检查器）中点击Localize，目的是选择我们需要本地化的语言，如下图： 点击Localize后，会弹出一个对话框，展开对话框列表，发现下拉列表所展示的语言正是我们在上面配置的需要国际化的语言，选择我们需要本地化的语言，然后点击对话框的Localize按钮，如下图： 勾选所有的语言，如下图： 分别给不同的语言给InfoPlist.strings下的文件设置对应的名字。 在Localize.strings(english)中加入如下代码： 1\"home\" = \"home\"; 在Localize.strings(Simplified)中加入如下代码： 1\"home\" = \"首页\"; 获取上述例子中“home”的值，代码如下： 1NSString *home = NSLocalizedString(@\"home\", nil); 模拟器语言环境”英语”,如下图： 模拟器语言环境”简体中文”,如下图： 多人开发情况下的字符串本地化项目开发中，独立开发的还是少数。经常会有多人开发的情况，这种情况，如果多人同时操作本地化文件，极有可能会存在冲突。另一方面，我们又不希望自己的本地化文件受到对方的污染，也就是说，我们不希望对方操作我们的本地化文件。但是上面介绍的代码中字符串的本地化是使用的是默认的文件名”Localizable”,因为启动程序时，系统将根据语言加载相应的文件得到其对应的字符串文件，这个字符串可以通过系统将NSLocalizedString中的宏生成名为“Localizable.strings”的文件。那么如何让系统加载我们自己命名的本地化文件而非系统默认的Localizable.strings呢？这就是 NSLocalizedStringFromTable(&lt;#key#&gt;, &lt;#tbl#&gt;, &lt;#comment#&gt;)的用处。也就是说，如果你的strings文件名字不是Localizable而是自定义的话，如VVS.strings，那么你就得使用NSLocalizedStringFromTable这个宏来读取本地化字符串。1234// key：系统根据key取字符串// tbl：自定义strings文件的名字// comment：可以不传NSLocalizedStringFromTable(&lt;#key#&gt;, &lt;#tbl#&gt;, &lt;#comment#&gt;) 创建新的strings文件：随便添加的字段：调试结果： 图片本地化本地化图片，有两种方式，第一种方式和本地化代码中的字符串一样，通过NSLocalizedString(key,comment)来获取相应的字符串，然后根据这个字符串再获取图片。 方式一： 123NSString *imageName = NSLocalizedString(@\"icon\", nil);UIImage *image = [UIImage imageNamed:imageName];self.imageView.image = image; 方式二： 先将照片添加到项目中，然后点击Localize，本文以arrow.png为例，如下图： 点击Localize后，跳出下图，点击localize 然后选择所有语言，如下图： 上述案例中的arrow.png中出现三角符号，点开可以看到对应语言的arrow.png 选中相应语言的照片，右击arrow.png-&gt;show in Finder，可以看到相对应语言的文件夹，将相对应的照片放进去即可 切换不同语言查看效果 123456UIImageView *imageview = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];[self.view addSubview:imageview];imageview.center = self.view.center;//获取图标名称NSString *imageName = NSLocalizedString(@\"arrow\", nil);[imageview setImage:[UIImage imageNamed:imageName]]; “英语”环境 “简体中文”环境 查看/切换本地语言应用启动时，首先会读取NSUserDefaults中的key为AppleLanguages对应的value，该value是一个String数组123NSArray *languages = [[NSUserDefaults standardUserDefaults] valueForKey:@\"AppleLanguages\"];NSString *currentLanguage = languages.firstObject;NSLog(@\"模拟器当前语言：%@\",currentLanguage); 同理可查看语言，也可以设置语言12345678910111213// 切换语言前NSArray *langArr1 = [[NSUserDefaults standardUserDefaults] valueForKey:@\"AppleLanguages\"];NSString *language1 = langArr1.firstObject;NSLog(@\"模拟器语言切换之前：%@\",language1);// 切换语言NSArray *lans = @[@\"en\"];[[NSUserDefaults standardUserDefaults] setObject:lans forKey:@\"AppleLanguages\"];// 切换语言后NSArray *langArr2 = [[NSUserDefaults standardUserDefaults] valueForKey:@\"AppleLanguages\"];NSString *language2 = langArr2.firstObject;NSLog(@\"模拟器语言切换之后：%@\",language2); – 完结 –","categories":[{"name":"IOS开发","slug":"IOS开发","permalink":"http://yoursite.com/categories/IOS开发/"}],"tags":[{"name":"本地化","slug":"本地化","permalink":"http://yoursite.com/tags/本地化/"}]},{"title":"3D Touch开发","slug":"3D-Touch开发","date":"2018-07-11T07:18:44.000Z","updated":"2018-07-16T08:05:52.314Z","comments":true,"path":"2018/07/11/3D-Touch开发/","link":"","permalink":"http://yoursite.com/2018/07/11/3D-Touch开发/","excerpt":"","text":"3D Touch3D Touch 是一种立体触控技术，被苹果称为新一代多点触控技术，是在 Apple Watch 上采用的 Force Touch，屏幕可感应不同的感压力度触控。 3D Touch有三大模块： peek and pop 常用于UITableView与UICollectionView中，长按Cell会预览 Home Screen Quick Actions 点击图片弹出快速入口 Force Properties Home Screen Quick Actions开发指南3D Touch快速入口标签有两种添加方式：一种是静态添加，在工程中的info.plist文件中添加相关项目。项目安装就可以使用另一种是动态添加，通过代码给App添加快速入口。项目运行一次后，可以唤醒标签 info.plist静态添加入静态添加入口标签不需要写代码，只需要在info.plist文件中添加相关功能设置即可。在info.plist中添加如下信息： 分析一下添加的项目分别代表什么意思。首先是UIApplicationShortcutItems，他是一个数组类型，数组中的每一个元素表示一个入口标签。然后是Item0，这是数组中的一个元素，字典类型。在这个字典中配置各个标签的相关属性。 字段名 功能 是否必须 备注 UIApplicationShortcutItemType UIApplicationShortcutItem对象的唯一标识符 true 监听该项的值来判断用户是从哪一个标签进入App的，该字段的值可以为空。 UIApplicationShortcutItemTitle UIApplicationShortcutItem对象的标题 true UIApplicationShortcutItemSubtitle UIApplicationShortcutItem对象的副标题 false UIApplicationShortcutItemIconType UIApplicationShortcutItem对象的图标类型 false UIApplicationShortcutItemIconFile 自定义标签图片文件的路径 false UIApplicationShortcutItemUserInfo 用户信息，是一个字典类型，可以用来传值 false 动态添加入口代码来添加，首先来认识三个类： 类名 功能描述 UIApplicationShortcutItem 创建标签的类 UIMutableApplicationShortcutItem 创建可变标签类 UIApplicationShortcutIcon 创建标签icon的类 创建一个新工程，AppDelegate中添加如下代码：1234567891011121314- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; if (@available(iOS 9.0, *)) &#123; //创建标签 UIApplicationShortcutItem *item1 = [[UIApplicationShortcutItem alloc] initWithType:@\"Share\" localizedTitle:@\"Share\" localizedSubtitle:@\"Share\" icon:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeShare] userInfo:nil]; UIApplicationShortcutItem *item2 = [[UIApplicationShortcutItem alloc] initWithType:@\"详情\" localizedTitle:@\"详情\" localizedSubtitle:@\"详情\" icon:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeHome] userInfo:nil]; UIApplicationShortcutItem *item3 = [[UIApplicationShortcutItem alloc] initWithType:@\"测试\" localizedTitle:@\"测试\" localizedSubtitle:@\"测试\" icon:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeLove] userInfo:nil]; //将标签添加进Application的shortcutItems中。 NSMutableArray *itemArray = [NSMutableArray arrayWithObjects:item1,item2,item3, nil]; [UIApplication sharedApplication].shortcutItems = itemArray; &#125;else&#123; NSLog(@\"设备不支持3D-Touch\"); &#125; return YES;&#125; 系统提供了如下样式的标签：12345678910111213141516171819202122232425262728293031typedef NS_ENUM(NSInteger, UIApplicationShortcutIconType) &#123; UIApplicationShortcutIconTypeCompose, UIApplicationShortcutIconTypePlay, UIApplicationShortcutIconTypePause, UIApplicationShortcutIconTypeAdd, UIApplicationShortcutIconTypeLocation, UIApplicationShortcutIconTypeSearch, UIApplicationShortcutIconTypeShare, UIApplicationShortcutIconTypeProhibit NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeContact NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeHome NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeMarkLocation NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeFavorite NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeLove NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeCloud NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeInvitation NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeConfirmation NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeMail NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeMessage NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeDate NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeTime NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeCapturePhoto NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeCaptureVideo NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeTask NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeTaskCompleted NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeAlarm NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeBookmark NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeShuffle NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeAudio NS_ENUM_AVAILABLE_IOS(9_1), UIApplicationShortcutIconTypeUpdate NS_ENUM_AVAILABLE_IOS(9_1)&#125; NS_ENUM_AVAILABLE_IOS(9_0) __TVOS_PROHIBITED; 系统图标不满足需求，可以使用+ (instancetype)iconWithTemplateImageName:(NSString *)templateImageName;添加自定义图片作为标签，需要注意的是：图片必须预先添加进bundle。 通过点击3D Touch启动App在AppDelegate中与如下方法123-(void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler&#123;&#125; 此方法的shortcutItem参数携带了从快速入口进入app时的标签参数。判断shortcutItem.localizedTitle属性的值来判断是从哪一个标签进入的App。 至此 3D Touch就介绍完毕了。由于技术有限，时间匆忙，难免会存在纰漏，欢迎指正","categories":[{"name":"IOS开发","slug":"IOS开发","permalink":"http://yoursite.com/categories/IOS开发/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"MVVM 与 ReactiveCocoa","slug":"MVVM-and-RAC","date":"2018-07-10T05:46:58.000Z","updated":"2018-07-16T08:07:13.688Z","comments":true,"path":"2018/07/10/MVVM-and-RAC/","link":"","permalink":"http://yoursite.com/2018/07/10/MVVM-and-RAC/","excerpt":"","text":"MVVM模式与RAC MVVM 是 MVC 模式的一种演进，它主要解决了 ViewController 过于臃肿带来的不易维护和测试的问题。其中 ViewModel 的主要职 责是处理业务逻辑并提供 View 所需的数据，这样 VC 就不用关心业务，自然也就瘦了下来。ViewModel 只关心业务数据不关心 View，所以不会与 View 产生耦合，也就更方便进行单元测试。 View 是一个壳，它所呈现的内容都需要由 ViewModel 来提供，而 View 又不与 ViewModel 直接沟通，这时就需要 ViewController 来做中间的协调者。ViewController 持有 View和 ViewModel，当 VC初始化时，会让 ViewModel 去取数据，简单来说就是调用 VM 的某个获取数据的方法。 使用 MVVM 最舒服的姿势是搭配 ReactiveCocoa。不过它的问题在于学习成本和维护成本比较高，在小团队中或许还可以尝试，当开发人员数量较多时就很难推起来了。这也是我们今天要讲的主题：如何不借助 ReactiveCocoa 来实现 MVVM。 先从数据的获取开始说起吧。在 ReactiveCocoa 里有一个类叫「RACCommand」，它的主要作用是执行某个会改变数据的操作，然后提供获取数据的方法，跟我们想要达到的目的很像，所以可以借鉴这个思路，写一个简单的 Command。 12345678910111213141516171819202122232425262728293031typedef void(^MGJCommandCompletionBlock)(id error, id content);// 1typedef void(^MGJCommandConsumeBlock)(id input, MGJCommandCompletionBlock completionHandler);// 2typedef void(^MGJCommandCancelBlock)();@interface MGJCommandResult : NSObject// 3@property (nonatomic) NSError *error;// 4@property (nonatomic) id content;@end@interface MGJCommand : NSObject// 5@property (nonatomic, readonly) BOOL executing;// 6@property (nonatomic, readonly) MGJCommandResult *result;- (instancetype)initWithConsumeHandler:(MGJCommandConsumeBlock )consumeHandler;// 7- (instancetype)initWithConsumeHandler:(MGJCommandConsumeBlock )consumeHandler cancelHandler:(MGJCommandCancelBlock )cancelHandler;// 8- (void)execute:(id)input;// 9- (void)cancel;@end 1.input是外部传过来的值，比如 user_id，当拿到数据后，调用下 completionHandler，这样 result 属性就会变化2.有些操作，如 http 请求，需要手动取消3.单独把 error作为一个属性放出来，是因为很多数据请求操作都可能出错，当出错后，只需改变这个 error 属性即可。4.content 存放了这个 Command 的数据处理结果。5.标识了这个 Command 目前的运行状态，比如可以根据这个状态来显示 loading。6.每次 Command 执行完一个任务后，result 都会改变，外部可以 KVO 这个 result，然后就可以实时获取最新的结果了。7.Command 的执行逻辑，如果实现了 cancelHandler 的话，外部调用 cancel，这个 Handler 就会被触发。8.外部可以调用这个方法来触发 Command 的执行，同时可以传一个参数进来。9.外部可以调用这个方法来取消 Command 的执行。 实现起来也蛮简单的，这里就不多说了。用起来大概是这样： 1234567891011// SomeViewModel.m@weakify(self);self.followCommand = [[MGJCommand alloc] initWithConsumeHandler:^(id input, MGJCommandCompletionBlock completionHandler) &#123; @strongify(self); [FollowRequest getFollowList:(NSDictionary *)input success:^(NSArray *users) &#123; self.usersToFollow = users; completionHandler(nil, kFollowExpertSearchSucceedSignal); &#125; failure:^(StatusEntity *error) &#123; completionHandler(error, nil); &#125;];&#125;]; 在 ViewController 里的用法大概像这样1234567// SomeViewController.m- (void)didTapFollowButton:(UIButton *)button&#123; // 根据 button 找到 userID [self.viewModel.followCommand execute:userID];&#125; 就是这样，VC 本身不处理业务逻辑，都交给 ViewModel 去处理，而这些数据请求的结果处理又有不同的处理方式。 Delegate当 ViewModel 拿到数据后，可以把结果以 Delegate 的方式通知 VC，就像这样1234567// SomeViewController.m- (void)didFollowUserWithResult:(id)result&#123; self.followButton.enabled = YES; [self.followButton doSomeAnimation];&#125; 这样做的好处是比较符合苹果既有的设计模式，而且也可以通过查看 Delegate 协议来知道 VM 暴露了哪些接口供外部使用。 不过这种方法少了点灵活性，比如需要联合多个属性的变化来做一些事情时，处理起来就会比较麻烦，这也是 RAC 强大的地方。 KVORAC 是基于 KVO 构建的，所以也可以用 KVO 来让 VC 获取 VM 的变化。但我们都知道 KVO 的槽点比较多，比如使用起来不方便，用完还要记得移除等。这里可以使用 Facebook 开源的 KVOController，它比较好的处理了 KVO 存在的一些问题，同时又能发挥 KVO 带来的便捷性。有了它我们就能在一个地方把 VM 的更新处理掉了123456789- (void)handleViewModelUpdate&#123; [self.KVOController observe:self.viewModel keyPath:@\"followCommand.result\" options:NSKeyValueObservingOptionInitial|NSKeyValueObservingOptionNew block:^(id observer, id target, NSDictionary *change) &#123; id newValue = change[NSKeyValueChangeNewKey]; // doSomething with the newValue &#125;]; // 对 VM 其他 keyPath 的处理也都可以放到这里&#125; 如果觉得这样的写法还是太麻烦，可以做一层简单的封装，使用起来就像这样 123456- (void)handleViewModelUpdate&#123; [self observe:self.viewModel keyPath:@\"followCommand.result\" block: ^(id newValue)&#123; // use newValue to update view &#125;];&#125; 是不是会好一点，使用 KVO 比 Delegate 好的一点是不用再额外声明协议和方法，而且支持 block，使用起来也会方便些。对于像 error 这样很多操作都会产生同样结果的场景，可以单独拿出来，作为 ViewModel 的一个属性，使用时，直接 KVO 这个属性即可。 细节处理如果不涉及到 TableView 等会出现复用场景的地方，MVVM 使用起来还是比较方便的。如果有了 TableView，又要做一些额外的处理。 一般来说，VC 可以带一个 VM，那如果出现 Cell 时怎么办，Cell 里又包含了按钮，按钮又需要数据请求又怎么处理？这些都是比较常见的场景，也可以通过 MVVM 来解决。 我们知道 VM 的职责是为 View 提供数据支持，Cell 也是一个 View，那么为 Cell 配备一个 VM 不就可以了么。 这样的话，VC 的 VM 需要包含一个数组，里面的元素是 CellVM，使用起来就像这样 1234567891011121314// SomeViewController.m- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"Cell\" forIndexPath:indexPath]; cell.viewModel = self.viewModel.cellViewModels[indexPath.row]; // cell 可能会用到 cellVM 里的 Command，所以在这里处理 command 的执行结果 [self observe:cell keyPath:@\"likeCommand.result\" block: ^(id newValue)&#123; // update cell after like &#125;]; return cell&#125; 当然仅仅如此是不够的，我们需要找个恰当的时机把 KVO 移除，避免多次监听。UITableViewDelegate 里的这个方法就很适合。 123456// SomeViewController.m- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath&#123; [self unobserve:cell keyPath:@\"likeCommand.result\"];&#125; 不过这里也要讲究一个平衡，如果 Cell 的类型比较多，且涉及 Command 的地方不多，只是做呈现方面的工作，直接使用 Entity 会更方便。 Tips ViewController 尽量不涉及业务逻辑，让 ViewModel 去做这些事情。 ViewController 只是一个中间人，接收 View 的事件、调用 ViewModel 的方法、响应 ViewModel 的变化。 ViewModel 不能包含 View，不然就跟 View 产生了耦合，不方便复用和测试。 ViewModel 之间可以有依赖。 ViewModel 避免过于臃肿，不然维护起来也是个问题。MVVM 并不复杂，跟 MVC 也是兼容的，只是多了一个 ViewModel 层，但就是这么一个小改动，就能让代码变得更加容易阅读和维护，不妨试一下吧。 以上为记录贴","categories":[{"name":"IOS开发","slug":"IOS开发","permalink":"http://yoursite.com/categories/IOS开发/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"第一篇博客","slug":"Prolusion","date":"2018-07-09T02:32:01.000Z","updated":"2018-07-17T01:17:50.234Z","comments":true,"path":"2018/07/09/Prolusion/","link":"","permalink":"http://yoursite.com/2018/07/09/Prolusion/","excerpt":"","text":"站点搭建及由来：看着同事在迁移博客，不由得想想我是不是需要一个博客来记录自己遇到的问题和一些见解，然后决定自己弄一个博客玩玩。 安装安装前提需要安装 Node.js 和 Git 两个应用程序，直接到官网安装最新版本即可，如已安装请跳过。 Node.js 官网 Git 官网 安装Hexo安装完Node.js 及 Git 后，即可在终端使用npm来安装Hexo：1$ npm install -g hexo-cli 如遇到权限问题，请使用如下代码安装Hexo：1$ sudo npm install -g hexo-cli 初始化Hexo123$ hexo init HexoBlog$ cd ~/HexoBlog/$ npm install 新建完成后，得到一下目录：12345678·|-- _config.yml|-- package.json|-- scaffolds|-- source| |-- _drafts| |-- _posts|-- themes 到这里您已经完成了Hexo的安装及初始化，接下来我们就可以进行本地的预览啦：先安装hexo server1$ sudo npm install hexo-server 然后生成本地页面并运行12$ hexo generate (或 hexo g)$ hexo server (或 hexo s) 按命令行提示，打开 http:\\/\\/localhost:4000\\/ 即可看到默认主题的默认页面了。可能加载会很慢，因为默认主题中使用了些Google的资源，后面更换主题就会快很多了。 配置与Github账户关联首先需要去Github注册一个账号，并新建一个名为 [your_account].github.io 的仓库。然后打开前面创建的HexoBlog目录下的 _config.yml 文件，在修改最下方的deploy为：*注意，冒号后面一定要加空格1234deploy: type: git repo: gihub: https://github.com/[your_account]/[your_accout].github.io.git branch: master 接下来安装hexo的git部署，在命令行中执行：1$ npm install hexo-deployer-git --save 最后，将生成静态页面并部署到github的仓库中，执行：1234$ hexo d -g 或者$ hexo generate$ hexo deploy 当提示 INFO Deploy done: git 即上传成功，这时就可以通过 http:\\/\\/[your_account].github.io 来访问你的个人站点了。 hexo的基本配置以下是hexo配置文件 _config.yml 的基本内容及基本设置，更多个性化设置请参考官方文档：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site ##页面信息title: Who's Blog ##标题，即浏览器标签栏显示的内容subtitle: Why so serious? ##副标题description: ##描述，简介author: Charles Wei ##作者language: zh-CN ##语言timezone: Asia/Shanghai ##时区# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://wwww.charleswei.me ##域名，后面自定义域名后，写在这里，用 .github.io的话，这里用默认的不用改root: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory ##文件目录，可不改source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing ##静态页面生成属性，可不改new_post_name: :year-:month-:day-:title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag ##标签，可不改default_category: uncategorizedcategory_map:tag_map:# Date / Time format ##时间格式，可不改## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination ##每页显示文章数，按需改## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions ##主题设置## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: indigo# Deployment ##git部署关联## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: https://github.com/glassweichao/glassweichao.github.io.git branch: master 主题配置Hexo具有高定制的主题效果，你可以从Hexo的主题库中选择合适的主题，也可以自己制作。以我现在使用的indigo主题为例。首先将主题库clone到MyBlog目录下的themes目录：1$ git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 安装less，主题使用less作为css预处理工具：1$ npm install hexo-renderer-less --save 安装feed,用于生吃RSS：1$ npm install hexo-generator-feed --save 安装json-content，用于生成静态站点数据，提供搜索功能的数据源：1$ npm install hexo-generator-json-content --save 开启标签页：1$ hexo new page tags 修改HexoBlog/source/tags/index.md的源数据：1234layout: tagsnoDate: truecomments: false--- 修改hexo配置文件_config.yml中的主题标签：1theme: indigo 最后修改主题配置文件MyBlog/themes/indigo/_config.yml：1234567891011121314151617181920212223242526272829303132333435363738#添加新菜单项遵循以下规则# menu:# link: fontawesome图标，省略前缀，本主题前缀为 icon-，必须# text: About 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写# url: /about 链接，绝对或相对路径，必须。# target: _blank 是否跳出，省略则在当前页面打开menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags github: url: https://github.com/glassweichao target: _blank link: text: 测试 url: /404rss: /atom.xml#你的头像,替换掉 indigo/source/img/logo.jpg 即可urlavatar: /img/logo.jpg# Contenttags: title: 标签#是否开启分享share: true#是否开启搜索search: true#是否大屏幕下文章页隐藏导航hideMenu: true#是否开启toc#toc: false 关闭toctoc: list_number: true # 是否显示数字排序#浏览器标签栏小图标favicon: /favicon.ico 最后生成部署，来看看效果吧12$ hexo clean$ hexo d -g 待办购买一个域名，然后绑定到当前页面 – 完结 –","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]}